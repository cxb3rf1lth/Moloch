#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
RexPloit - Master Unified Framework
Professional Penetration Testing Tool with Advanced Features
For authorized security testing only
"""

import os
import sys
import argparse
import logging
import textwrap
import json
from datetime import datetime
from rich.console import Console
from rich.panel import Panel
from rich.prompt import Confirm, Prompt
from rich.progress import Progress, SpinnerColumn, TextColumn
from rich.table import Table
from rich import print as rprint

# Import RexPloit modules
from dependency_manager import DependencyManager
import rexploit_core as core
import enhancements

# Version info
VERSION = "2.0.0"
CODENAME = "Cerberus"

# Setup console for rich output
console = Console()

def setup_logging():
    """Configure logging for the application"""
    log_format = "[%(asctime)s] [%(levelname)s] %(message)s"
    date_format = "%Y-%m-%d %H:%M:%S"
    
    # Create logs directory if it doesn't exist
    os.makedirs("logs", exist_ok=True)
    
    # Configure root logger
    logging.basicConfig(
        level=logging.INFO,
        format=log_format,
        datefmt=date_format,
        handlers=[
            logging.FileHandler("logs/rexploit_unified.log"),
            logging.StreamHandler()
        ]
    )
    
    return logging.getLogger("rexploit")

def show_banner():
    """Display RexPloit banner"""
    banner = f"""
    ██████╗ ███████╗██╗  ██╗██████╗ ██╗      ██████╗ ██╗████████╗
    ██╔══██╗██╔════╝╚██╗██╔╝██╔══██╗██║     ██╔═══██╗██║╚══██╔══╝
    ██████╔╝█████╗   ╚███╔╝ ██████╔╝██║     ██║   ██║██║   ██║   
    ██╔══██╗██╔══╝   ██╔██╗ ██╔═══╝ ██║     ██║   ██║██║   ██║   
    ██║  ██║███████╗██╔╝ ██╗██║     ███████╗╚██████╔╝██║   ██║   
    ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚═╝     ╚══════╝ ╚═════╝ ╚═╝   ╚═╝   
                                                              
    v{VERSION} "{CODENAME}" - Professional Penetration Testing Framework
    FOR AUTHORIZED SECURITY TESTING ONLY
    """
    
    console.print(Panel(banner, style="bold blue", border_style="blue"))
    console.print("\n[bold yellow]WARNING: Use responsibly and only on systems you have permission to test.[/bold yellow]\n")

def check_authorization():
    """Verify user has authorization to use the tool"""
    console.print("[bold]Authorization Required[/bold]")
    console.print("This tool is for professional security testing only.")
    console.print("You must have explicit permission to test the target systems.")
    
    return Confirm.ask("Do you have proper authorization for all targets?", default=False)
    
def check_dependencies(install=False):
    """Check and install dependencies if needed"""
    console.print("[bold blue]Checking dependencies...[/bold blue]")
    
    try:
        manager = DependencyManager()
        
        if install:
            result = manager.check_all_dependencies(auto_install=True)
            if not result:
                console.print("[bold yellow]Some dependencies could not be installed.[/bold yellow]")
                console.print("You may need to install them manually.")
            return result
        else:
            result = manager.check_all_dependencies(auto_install=False)
            if not result:
                if Confirm.ask("Install missing dependencies now?", default=True):
                    return manager.check_all_dependencies(auto_install=True)
                else:
                    console.print("[bold yellow]Some dependencies are missing.[/bold yellow]")
                    console.print("The tool may not function correctly without them.")
            return result
    except Exception as e:
        console.print(f"[bold red]Error checking dependencies: {str(e)}[/bold red]")
        return False
        
def parse_arguments():
    """Parse command-line arguments with enhanced CLI support"""
    parser = argparse.ArgumentParser(
        prog='rexploit',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description=textwrap.dedent(f'''
        RexPloit v{VERSION} "{CODENAME}" - Professional Penetration Testing Framework
        For authorized security testing only
        
        This tool provides comprehensive penetration testing capabilities including:
        - C2 framework management (Sliver, Villain, HoaxShell)
        - Payload generation and deployment
        - Vulnerability scanning
        - Network reconnaissance
        - Security reporting
        '''),
        epilog=textwrap.dedent('''
        Examples:
          rexploit --cli payload --type python --lhost 192.168.1.100 --lport 4444
          rexploit --cli c2 --framework sliver --start
          rexploit --cli scan --target 192.168.1.0/24
          rexploit --cli report --format html --output /tmp/report.html
        
        For interactive mode, simply run: rexploit --cli
        ''')
    )
    
    # Main mode arguments
    parser.add_argument("--cli", action="store_true", 
                      help="Run in CLI mode (default behavior)")
    parser.add_argument("--interactive", action="store_true",
                      help="Run in interactive CLI mode")
    parser.add_argument("--install", action="store_true", 
                      help="Install missing dependencies")
    parser.add_argument("--check", action="store_true", 
                      help="Check dependencies without installing")
    parser.add_argument("--test", action="store_true", 
                      help="Run test suite")
    parser.add_argument("--debug", action="store_true", 
                      help="Enable debug logging")
    parser.add_argument("--config", metavar="FILE", 
                      help="Use alternative config file")
    parser.add_argument("--output", metavar="DIR", 
                      help="Output directory for reports and payloads")
    parser.add_argument("--version", action="version", 
                      version=f"RexPloit v{VERSION} ({CODENAME})")
    
    # Create subparsers for different operations
    subparsers = parser.add_subparsers(dest='command', help='Available commands')
    
    # Payload generation subcommand
    payload_parser = subparsers.add_parser('payload', help='Generate advanced payloads')
    payload_parser.add_argument("--type", choices=["python", "bash", "powershell", "php", "perl", 
                                                  "python_advanced", "powershell_advanced", "web_advanced",
                                                  "staged_advanced", "polymorphic"], 
                              help="Payload type to generate", required=True)
    payload_parser.add_argument("--lhost", help="Listener host", required=True)
    payload_parser.add_argument("--lport", type=int, help="Listener port", required=True)
    payload_parser.add_argument("--encode", action="store_true", help="Encode payload")
    payload_parser.add_argument("--obfuscate", action="store_true", help="Obfuscate payload")
    payload_parser.add_argument("--output-file", help="Output file for payload")
    
    # Advanced payload options
    payload_parser.add_argument("--evasion-level", choices=["basic", "medium", "advanced"],
                              default="medium", help="Evasion technique level")
    payload_parser.add_argument("--persistence", choices=["none", "registry", "crontab", "service"],
                              default="none", help="Persistence mechanism")
    payload_parser.add_argument("--execution-method", choices=["subprocess", "eval", "system"],
                              default="subprocess", help="Command execution method")
    payload_parser.add_argument("--polymorphic", action="store_true", help="Generate polymorphic payload")
    payload_parser.add_argument("--encoding", choices=["base64", "hex", "rot13"], help="Encoding type")
    
    # Fuzzing subcommand
    fuzz_parser = subparsers.add_parser('fuzz', help='Generate fuzzing payloads')
    fuzz_parser.add_argument("--base-type", choices=["python", "bash", "powershell", "php", "perl"],
                           help="Base payload type for fuzzing", required=True)
    fuzz_parser.add_argument("--lhost", help="Listener host", required=True)
    fuzz_parser.add_argument("--lport", type=int, help="Listener port", required=True)
    fuzz_parser.add_argument("--iterations", type=int, default=50, help="Number of fuzzing variants")
    
    # Injection payloads subcommand
    injection_payloads_parser = subparsers.add_parser('injection-payloads', help='Generate injection payloads')
    injection_payloads_parser.add_argument("--vector", choices=["sql_injection", "xss_injection", "command_injection",
                                                              "ldap_injection", "xpath_injection", "nosql_injection",
                                                              "template_injection", "code_injection"],
                                         help="Injection vector type", required=True)
    
    # Enhanced C2 framework subcommand
    c2_parser = subparsers.add_parser('c2', help='Manage C2 frameworks with automation')
    c2_parser.add_argument("--framework", choices=["sliver", "villain", "hoaxshell"], 
                         help="C2 framework to use", required=True)
    c2_group = c2_parser.add_mutually_exclusive_group(required=True)
    c2_group.add_argument("--start", action="store_true", help="Start C2 framework")
    c2_group.add_argument("--stop", action="store_true", help="Stop C2 framework")
    c2_group.add_argument("--status", action="store_true", help="Check C2 framework status")
    c2_group.add_argument("--listeners", action="store_true", help="List active listeners")
    c2_group.add_argument("--sessions", action="store_true", help="List active sessions")
    c2_parser.add_argument("--auto-listener", action="store_true", help="Auto-setup listener on start")
    c2_parser.add_argument("--automation", action="store_true", help="Enable automation features")
    
    # Automation subcommand
    automation_parser = subparsers.add_parser('automation', help='Manage automation workflows')
    automation_subparsers = automation_parser.add_subparsers(dest='automation_action', help='Automation actions')
    
    # Start workflow
    start_workflow_parser = automation_subparsers.add_parser('start', help='Start automation workflow')
    start_workflow_parser.add_argument("--template", choices=["recon_and_exploit", "payload_fuzzing", 
                                                            "c2_automation", "stealth_operation"],
                                     help="Workflow template", required=True)
    start_workflow_parser.add_argument("--name", help="Workflow name", required=True)
    start_workflow_parser.add_argument("--targets", nargs="+", help="Target systems", required=True)
    start_workflow_parser.add_argument("--delay", type=int, default=0, help="Delay before starting (seconds)")
    
    # Workflow status
    status_workflow_parser = automation_subparsers.add_parser('status', help='Check workflow status')
    status_workflow_parser.add_argument("--name", help="Workflow name (or 'all' for all workflows)")
    
    # List workflows
    list_workflow_parser = automation_subparsers.add_parser('list', help='List workflows')
    
    # Cancel workflow
    cancel_workflow_parser = automation_subparsers.add_parser('cancel', help='Cancel workflow')
    cancel_workflow_parser.add_argument("--name", help="Workflow name", required=True)
    
    # Scanning subcommand
    scan_parser = subparsers.add_parser('scan', help='Perform security scans')
    scan_parser.add_argument("--target", help="Target to scan", required=True)
    scan_parser.add_argument("--type", choices=["vuln", "network", "port"], 
                           default="vuln", help="Type of scan to perform")
    scan_parser.add_argument("--threads", type=int, default=10, help="Number of threads")
    scan_parser.add_argument("--timeout", type=int, default=30, help="Scan timeout")
    
    # Enhanced injection subcommand
    inject_parser = subparsers.add_parser('inject', help='Deploy payloads with advanced vectors')
    inject_parser.add_argument("--payload", help="Payload file to deploy", required=True)
    inject_parser.add_argument("--targets", nargs="+", help="Target systems", required=True)
    inject_parser.add_argument("--methods", nargs="+", 
                             choices=["ssh", "smb", "http", "web_upload", "email_attachment", 
                                    "usb_drop", "social_engineering", "supply_chain", 
                                    "watering_hole", "dns_hijack", "mitm", "phishing"],
                             default=["ssh", "http", "smb"], help="Injection methods")
    inject_parser.add_argument("--validate-targets", action="store_true", help="Validate targets before injection")
    inject_parser.add_argument("--payload-name", help="Human-readable payload name")
    
    # Professional injection campaign
    campaign_parser = subparsers.add_parser('campaign', help='Run professional injection campaign')
    campaign_parser.add_argument("--payload", help="Payload file to deploy", required=True)
    campaign_parser.add_argument("--targets", nargs="+", help="Target systems", required=True)
    campaign_parser.add_argument("--methods", nargs="+",
                               choices=["ssh", "smb", "http", "web_upload", "email_attachment",
                                      "social_engineering", "phishing"],
                               default=["ssh", "http", "smb"], help="Injection methods")
    campaign_parser.add_argument("--name", help="Campaign name", required=True)
    
    # Reporting subcommand
    report_parser = subparsers.add_parser('report', help='Generate reports')
    report_parser.add_argument("--format", choices=["html", "pdf", "json", "csv"], 
                             default="html", help="Report format")
    report_parser.add_argument("--template", help="Report template file")
    report_parser.add_argument("--data", help="Data directory or file for report")
    
    # Configuration subcommand
    config_parser = subparsers.add_parser('config', help='Manage configuration')
    config_group = config_parser.add_mutually_exclusive_group(required=True)
    config_group.add_argument("--show", action="store_true", help="Show current configuration")
    config_group.add_argument("--set", nargs=2, metavar=("KEY", "VALUE"), help="Set configuration value")
    config_group.add_argument("--reset", action="store_true", help="Reset to default configuration")
    
    # Legacy compatibility arguments (for backward compatibility)
    parser.add_argument("--legacy", action="store_true", help=argparse.SUPPRESS)
    parser.add_argument("--payload", dest="legacy_payload", 
                      choices=["python", "bash", "powershell", "php", "perl"], 
                      help=argparse.SUPPRESS)
    parser.add_argument("--lhost", dest="legacy_lhost", help=argparse.SUPPRESS)
    parser.add_argument("--lport", dest="legacy_lport", type=int, help=argparse.SUPPRESS)
    parser.add_argument("--c2", dest="legacy_c2", 
                      choices=["sliver", "villain", "hoaxshell"], help=argparse.SUPPRESS)
    parser.add_argument("--scan", dest="legacy_scan", metavar="TARGET", help=argparse.SUPPRESS)
    parser.add_argument("--encode", dest="legacy_encode", action="store_true", help=argparse.SUPPRESS)
    parser.add_argument("--obfuscate", dest="legacy_obfuscate", action="store_true", help=argparse.SUPPRESS)
    
    return parser.parse_args()

def handle_cli_mode(args, logger):
    """Handle enhanced command-line interface mode"""
    logger.info("Starting RexPloit in professional CLI mode")
    
    # Load configuration
    config = core.load_config()
    
    # Override config with command-line arguments
    if args.legacy_lhost:
        config["listener_host"] = args.legacy_lhost
    if args.legacy_lport:
        config["listener_port"] = args.legacy_lport
    if args.legacy_c2:
        config["default_c2"] = args.legacy_c2
    if args.output:
        core.PAYLOAD_DIR = args.output
        core.LOG_DIR = os.path.join(args.output, "logs")
    
    # Initialize components
    logger = core.Logger()
    payload_gen = core.PayloadGenerator(config)
    c2_manager = core.C2Manager(config)
    injector = core.Injector()
    scanner = core.VulnerabilityScanner()
    
    # Initialize automation engine
    try:
        from automation_engine import AutomationEngine
        automation_engine = AutomationEngine(config, logger)
        automation_available = True
    except ImportError:
        automation_engine = None
        automation_available = False
        logger.warning("Automation engine not available")
    
    # Handle subcommands
    if args.command == 'payload':
        return handle_payload_command(args, payload_gen, logger)
    elif args.command == 'fuzz':
        return handle_fuzz_command(args, payload_gen, logger)
    elif args.command == 'injection-payloads':
        return handle_injection_payloads_command(args, payload_gen, logger)
    elif args.command == 'c2':
        return handle_c2_command(args, c2_manager, logger)
    elif args.command == 'automation':
        return handle_automation_command(args, automation_engine, logger)
    elif args.command == 'scan':
        return handle_scan_command(args, scanner, logger)
    elif args.command == 'inject':
        return handle_inject_command(args, injector, logger)
    elif args.command == 'campaign':
        return handle_campaign_command(args, injector, logger)
    elif args.command == 'report':
        return handle_report_command(args, logger)
    elif args.command == 'config':
        return handle_config_command(args, config, logger)
    
    # Handle legacy single-argument commands for backward compatibility
    elif args.legacy_payload:
        return handle_legacy_payload(args, payload_gen, logger)
    elif args.legacy_c2:
        return handle_legacy_c2(args, c2_manager, logger)
    elif args.legacy_scan:
        return handle_legacy_scan(args, scanner, logger)
    
    # Default: run interactive mode
    else:
        return run_interactive_cli(config, logger)

def handle_payload_command(args, payload_gen, logger):
    """Handle enhanced payload generation command"""
    console.print("[cyan]Generating advanced payload...[/cyan]")
    
    try:
        # Prepare advanced options
        advanced_options = {}
        if hasattr(args, 'evasion_level'):
            advanced_options['evasion_level'] = args.evasion_level
        if hasattr(args, 'persistence'):
            advanced_options['persistence'] = args.persistence
        if hasattr(args, 'execution_method'):
            advanced_options['execution_method'] = args.execution_method
        if hasattr(args, 'polymorphic'):
            advanced_options['polymorphic'] = args.polymorphic
        if hasattr(args, 'encoding'):
            advanced_options['encoding'] = args.encoding
        
        # Generate payload with enhanced features
        result = payload_gen.generate_payload(
            args.type, 
            args.lhost, 
            args.lport, 
            encode=args.encode, 
            obfuscate=args.obfuscate,
            **advanced_options
        )
        
        if result["success"]:
            console.print(f"[green]✓[/green] Payload generated successfully!")
            console.print(f"[dim]File:[/dim] {result['file_path']}")
            
            metadata = result["metadata"]
            
            # Create metadata table
            table = Table(title="Payload Metadata")
            table.add_column("Property", style="cyan")
            table.add_column("Value", style="green")
            
            table.add_row("Type", metadata["type"])
            table.add_row("Target Host", metadata["lhost"])
            table.add_row("Target Port", str(metadata["lport"]))
            table.add_row("Encoded", "Yes" if metadata["encoded"] else "No")
            table.add_row("Obfuscated", "Yes" if metadata["obfuscated"] else "No")
            table.add_row("Created", metadata["created"])
            table.add_row("Checksum", metadata["checksum"][:16] + "...")
            
            if metadata.get("advanced"):
                table.add_row("Advanced Features", "Enabled")
                table.add_row("Complexity Score", str(metadata.get("complexity_score", "N/A")))
            
            console.print(table)
            
            # Copy to custom location if specified
            if args.output_file:
                import shutil
                shutil.copy2(result["file_path"], args.output_file)
                console.print(f"[green]✓[/green] Payload copied to: {args.output_file}")
            
            return True
        else:
            console.print(f"[red]✗[/red] Failed to generate payload: {result['error']}")
            return False
            
    except Exception as e:
        console.print(f"[red]✗[/red] Error: {str(e)}")
        logger.error(f"Payload generation error: {str(e)}")
        return False

def handle_fuzz_command(args, payload_gen, logger):
    """Handle fuzzing payload generation command"""
    console.print("[cyan]Generating fuzzing payloads...[/cyan]")
    
    try:
        with Progress(SpinnerColumn(), TextColumn("[progress.description]{task.description}")) as progress:
            task = progress.add_task(f"Generating {args.iterations} fuzzing variants...", total=None)
            
            result = payload_gen.generate_fuzzing_payloads(
                args.base_type,
                args.lhost,
                args.lport,
                iterations=args.iterations
            )
        
        if result["success"]:
            console.print(f"[green]✓[/green] Fuzzing payloads generated successfully!")
            console.print(f"[dim]Directory:[/dim] {result['fuzzing_directory']}")
            console.print(f"[dim]Variants:[/dim] {result['total_variants']}")
            
            # Show sample variants
            table = Table(title="Sample Fuzzing Variants")
            table.add_column("ID", style="cyan")
            table.add_column("File", style="green")
            table.add_column("Mutations", style="yellow")
            
            for variant in result["variants"][:5]:  # Show first 5
                variant_id = str(variant["metadata"]["variant_id"])
                file_name = os.path.basename(variant["file_path"])
                mutations = ", ".join(variant["metadata"]["mutations_applied"])
                table.add_row(variant_id, file_name, mutations[:50] + "..." if len(mutations) > 50 else mutations)
            
            if len(result["variants"]) > 5:
                table.add_row("...", "...", f"... and {len(result['variants']) - 5} more variants")
            
            console.print(table)
            return True
        else:
            console.print(f"[red]✗[/red] Failed to generate fuzzing payloads: {result['error']}")
            return False
            
    except Exception as e:
        console.print(f"[red]✗[/red] Error: {str(e)}")
        logger.error(f"Fuzzing generation error: {str(e)}")
        return False

def handle_injection_payloads_command(args, payload_gen, logger):
    """Handle injection payload generation command"""
    console.print(f"[cyan]Generating {args.vector} injection payloads...[/cyan]")
    
    try:
        result = payload_gen.generate_injection_payloads(args.vector)
        
        if result["success"]:
            console.print(f"[green]✓[/green] Injection payloads generated successfully!")
            console.print(f"[dim]Directory:[/dim] {result['injection_directory']}")
            console.print(f"[dim]Payloads:[/dim] {result['total_payloads']}")
            
            # Show sample payloads
            table = Table(title=f"{args.vector.replace('_', ' ').title()} Payloads")
            table.add_column("ID", style="cyan")
            table.add_column("Payload", style="green")
            
            for payload_info in result["payloads"][:10]:  # Show first 10
                payload_id = str(payload_info["metadata"]["payload_id"])
                payload_content = payload_info["metadata"]["payload"]
                # Truncate long payloads
                if len(payload_content) > 60:
                    payload_content = payload_content[:60] + "..."
                table.add_row(payload_id, payload_content)
            
            if len(result["payloads"]) > 10:
                table.add_row("...", f"... and {len(result['payloads']) - 10} more payloads")
            
            console.print(table)
            return True
        else:
            console.print(f"[red]✗[/red] Failed to generate injection payloads: {result['error']}")
            return False
            
    except Exception as e:
        console.print(f"[red]✗[/red] Error: {str(e)}")
        logger.error(f"Injection payload generation error: {str(e)}")
        return False

def handle_automation_command(args, automation_engine, logger):
    """Handle automation workflow management"""
    if not automation_engine:
        console.print("[red]✗[/red] Automation engine not available")
        return False
    
    try:
        if args.automation_action == 'start':
            console.print(f"[cyan]Starting workflow '{args.name}' with template '{args.template}'...[/cyan]")
            
            # Create workflow
            result = automation_engine.create_workflow(args.name, args.template, args.targets)
            if not result["success"]:
                console.print(f"[red]✗[/red] Failed to create workflow: {result['error']}")
                return False
            
            # Start workflow
            start_result = automation_engine.start_workflow(args.name, args.delay)
            if start_result["success"]:
                console.print(f"[green]✓[/green] Workflow '{args.name}' started successfully")
                console.print(f"[dim]Template:[/dim] {args.template}")
                console.print(f"[dim]Targets:[/dim] {', '.join(args.targets)}")
                console.print(f"[dim]Start Time:[/dim] {start_result['start_time']}")
                
                # Start automation engine if not running
                automation_engine.start_automation_engine()
                
                return True
            else:
                console.print(f"[red]✗[/red] Failed to start workflow: {start_result['error']}")
                return False
        
        elif args.automation_action == 'status':
            if args.name and args.name.lower() != 'all':
                # Show specific workflow status
                status = automation_engine.get_workflow_status(args.name)
                if "error" in status:
                    console.print(f"[red]✗[/red] {status['error']}")
                    return False
                
                # Create status table
                table = Table(title=f"Workflow Status: {args.name}")
                table.add_column("Property", style="cyan")
                table.add_column("Value", style="green")
                
                table.add_row("Status", status["status"])
                table.add_row("Template", status["template"])
                table.add_row("Current Phase", status.get("current_phase", "None"))
                table.add_row("Created", status["created"])
                if status.get("start_time"):
                    table.add_row("Started", status["start_time"])
                if status.get("end_time"):
                    table.add_row("Completed", status["end_time"])
                if status.get("success_rate") is not None:
                    table.add_row("Success Rate", f"{status['success_rate']:.1%}")
                
                console.print(table)
                
                # Show phase results if available
                if status.get("results"):
                    results_table = Table(title="Phase Results")
                    results_table.add_column("Phase", style="cyan")
                    results_table.add_column("Status", style="green")
                    results_table.add_column("Execution Time", style="yellow")
                    
                    for phase_name, result in status["results"].items():
                        status_icon = "✓" if result.get("success") else "✗"
                        execution_time = f"{result.get('execution_time', 0):.1f}s"
                        results_table.add_row(phase_name, status_icon, execution_time)
                    
                    console.print(results_table)
                
            else:
                # Show overall automation status
                status = automation_engine.get_automation_status()
                
                table = Table(title="Automation Engine Status")
                table.add_column("Metric", style="cyan")
                table.add_column("Value", style="green")
                
                table.add_row("Engine Running", "Yes" if status["engine_running"] else "No")
                table.add_row("Active Workflows", str(status["active_workflows"]))
                table.add_row("Completed Workflows", str(status["completed_workflows"]))
                table.add_row("Scheduled Tasks", str(status["scheduled_tasks"]))
                table.add_row("Total Workflows", str(status["total_workflows"]))
                
                console.print(table)
            
            return True
        
        elif args.automation_action == 'list':
            workflows = automation_engine.list_workflows()
            
            if not workflows:
                console.print("[yellow]No workflows found[/yellow]")
                return True
            
            table = Table(title="Automation Workflows")
            table.add_column("Name", style="cyan")
            table.add_column("Template", style="green")
            table.add_column("Status", style="yellow")
            table.add_column("Targets", style="blue")
            table.add_column("Created", style="dim")
            
            for workflow in workflows:
                targets_str = ", ".join(workflow["targets"][:2])
                if len(workflow["targets"]) > 2:
                    targets_str += f" +{len(workflow['targets'])-2} more"
                
                table.add_row(
                    workflow["id"],
                    workflow["template"],
                    workflow["status"],
                    targets_str,
                    workflow["created"][:16]
                )
            
            console.print(table)
            return True
        
        elif args.automation_action == 'cancel':
            console.print(f"[cyan]Cancelling workflow '{args.name}'...[/cyan]")
            
            result = automation_engine.cancel_workflow(args.name)
            if result["success"]:
                console.print(f"[green]✓[/green] Workflow '{args.name}' cancelled")
                return True
            else:
                console.print(f"[red]✗[/red] Failed to cancel workflow: {result['error']}")
                return False
        
        else:
            console.print("[red]✗[/red] Unknown automation action")
            return False
            
    except Exception as e:
        console.print(f"[red]✗[/red] Automation error: {str(e)}")
        logger.error(f"Automation command error: {str(e)}")
        return False

def handle_campaign_command(args, injector, logger):
    """Handle professional injection campaign"""
    console.print(f"[cyan]Starting injection campaign '{args.name}'...[/cyan]")
    
    try:
        payload_name = args.name
        
        with Progress(SpinnerColumn(), TextColumn("[progress.description]{task.description}")) as progress:
            task = progress.add_task(f"Running injection campaign against {len(args.targets)} targets...", total=None)
            
            results = injector.professional_inject(
                targets=args.targets,
                payload_path=args.payload,
                payload_name=payload_name,
                methods=args.methods,
                validate_targets=True
            )
        
        # Analyze results
        successful = [r for r in results if r.get("status") == "success"]
        failed = [r for r in results if r.get("status") == "failed"]
        
        console.print(f"[green]✓[/green] Campaign '{args.name}' completed!")
        console.print(f"[dim]Successful:[/dim] {len(successful)}/{len(args.targets)}")
        console.print(f"[dim]Success Rate:[/dim] {len(successful)/len(args.targets):.1%}")
        
        # Results table
        table = Table(title="Campaign Results")
        table.add_column("Target", style="cyan")
        table.add_column("Status", style="green")
        table.add_column("Vector", style="yellow")
        table.add_column("Details", style="dim")
        
        for result in results:
            status_icon = "✓" if result.get("status") == "success" else "✗"
            vector = result.get("vector", "none")
            details = result.get("evidence", {}).get("message", result.get("error", ""))
            
            table.add_row(
                result.get("target", "unknown"),
                status_icon,
                vector,
                details[:50] + "..." if len(details) > 50 else details
            )
        
        console.print(table)
        
        # Show injection statistics
        stats = injector.get_injection_statistics()
        if stats["total_attempts"] > 0:
            stats_table = Table(title="Injection Statistics")
            stats_table.add_column("Metric", style="cyan")
            stats_table.add_column("Value", style="green")
            
            stats_table.add_row("Total Attempts", str(stats["total_attempts"]))
            stats_table.add_row("Successful", str(stats["successful_attempts"]))
            stats_table.add_row("Success Rate", f"{stats['overall_success_rate']:.1%}")
            if stats["most_successful_method"]:
                stats_table.add_row("Best Method", stats["most_successful_method"])
            
            console.print(stats_table)
        
        return len(successful) > 0
        
    except Exception as e:
        console.print(f"[red]✗[/red] Campaign error: {str(e)}")
        logger.error(f"Campaign error: {str(e)}")
        return False

def handle_c2_command(args, c2_manager, logger):
    """Handle C2 framework management command"""
    console.print(f"[cyan]Managing {args.framework} C2 framework...[/cyan]")
    
    try:
        if args.start:
            console.print(f"[cyan]Starting {args.framework} C2 framework...[/cyan]")
            success = c2_manager.start_framework(args.framework)
            
            if success:
                console.print(f"[bold green]{args.framework.capitalize()} C2 framework started successfully[/bold green]")
                console.print("[yellow]Press Ctrl+C to stop the framework[/yellow]")
                
                try:
                    # Keep running and show logs
                    while True:
                        import time
                        time.sleep(1)
                        
                        # Show any new logs
                        logs = c2_manager.get_logs()
                        for log in logs:
                            console.print(log)
                            
                except KeyboardInterrupt:
                    console.print("\n[yellow]Stopping framework...[/yellow]")
                    c2_manager.stop_framework()
                    console.print("[green]Framework stopped[/green]")
            else:
                console.print(f"[bold red]Failed to start {args.framework} C2 framework[/bold red]")
                return False
                
        elif args.stop:
            console.print(f"[cyan]Stopping {args.framework} C2 framework...[/cyan]")
            success = c2_manager.stop_framework()
            
            if success:
                console.print(f"[bold green]{args.framework.capitalize()} C2 framework stopped[/bold green]")
            else:
                console.print(f"[bold red]Failed to stop {args.framework} C2 framework[/bold red]")
                return False
                
        elif args.status:
            console.print(f"[cyan]Checking {args.framework} C2 framework status...[/cyan]")
            status = c2_manager.get_status()
            
            if status["active"]:
                console.print(f"[bold green]{args.framework.capitalize()} is running[/bold green]")
                console.print(f"[green]PID: {status.get('pid', 'Unknown')}[/green]")
                console.print(f"[green]Listeners: {status.get('listeners', 0)}[/green]")
                console.print(f"[green]Sessions: {status.get('sessions', 0)}[/green]")
            else:
                console.print(f"[bold yellow]{args.framework.capitalize()} is not running[/bold yellow]")
        
        return True
        
    except Exception as e:
        console.print(f"[bold red]Error managing C2 framework: {str(e)}[/bold red]")
        return False

def handle_scan_command(args, scanner, logger):
    """Handle scanning command"""
    console.print(f"[cyan]Scanning target: {args.target}[/cyan]")
    
    try:
        # Validate target
        from enhancements import TargetValidator
        validator = TargetValidator(logger)
        
        if not validator.validate_target(args.target):
            console.print(f"[bold red]Invalid target: {args.target}[/bold red]")
            return False
        
        # Run scan based on type
        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            console=console
        ) as progress:
            
            if args.type == "vuln":
                task = progress.add_task("Running vulnerability scan...", total=None)
                scan_results = scanner.scan_vulnerabilities(
                    args.target, 
                    threads=args.threads,
                    timeout=args.timeout
                )
            elif args.type == "network":
                task = progress.add_task("Running network scan...", total=None)
                from enhancements import NetworkScanner
                net_scanner = NetworkScanner(logger)
                scan_results = net_scanner.scan_network(args.target)
            elif args.type == "port":
                task = progress.add_task("Running port scan...", total=None)
                scan_results = scanner.scan_ports(
                    args.target,
                    timeout=args.timeout
                )
            
            progress.remove_task(task)
        
        # Display results
        if scan_results:
            console.print(f"[bold green]Scan completed successfully[/bold green]")
            
            # Create results table
            from rich.table import Table
            table = Table(title=f"{args.type.capitalize()} Scan Results")
            
            if args.type == "vuln":
                table.add_column("Vulnerability", style="red")
                table.add_column("Severity", style="yellow")
                table.add_column("Description", style="cyan")
                
                for vuln in scan_results:
                    table.add_row(vuln["name"], vuln["severity"], vuln["description"])
                    
            elif args.type in ["network", "port"]:
                table.add_column("Host", style="green")
                table.add_column("Port", style="cyan")
                table.add_column("Service", style="yellow")
                table.add_column("Status", style="red")
                
                for result in scan_results:
                    table.add_row(
                        result.get("host", ""),
                        str(result.get("port", "")),
                        result.get("service", ""),
                        result.get("status", "")
                    )
            
            console.print(table)
            
            # Save results
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            results_file = f"scan_results_{args.type}_{timestamp}.json"
            
            with open(results_file, 'w') as f:
                json.dump(scan_results, f, indent=2)
            
            console.print(f"[green]Results saved to: {results_file}[/green]")
            return True
        else:
            console.print("[yellow]No results found[/yellow]")
            return True
            
    except Exception as e:
        console.print(f"[bold red]Error during scan: {str(e)}[/bold red]")
        return False

def handle_inject_command(args, injector, logger):
    """Handle payload injection command"""
    console.print(f"[cyan]Deploying payload: {args.payload}[/cyan]")
    
    try:
        # Validate payload file exists
        if not os.path.exists(args.payload):
            console.print(f"[bold red]Payload file not found: {args.payload}[/bold red]")
            return False
        
        # Validate targets
        from enhancements import TargetValidator
        validator = TargetValidator(logger)
        valid_targets = []
        
        for target in args.targets:
            if validator.validate_target(target):
                valid_targets.append(target)
            else:
                console.print(f"[yellow]Skipping invalid target: {target}[/yellow]")
        
        if not valid_targets:
            console.print("[bold red]No valid targets found[/bold red]")
            return False
        
        console.print(f"[green]Deploying to {len(valid_targets)} target(s)[/green]")
        
        # Deploy payload
        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            console=console
        ) as progress:
            
            task = progress.add_task("Deploying payload...", total=len(valid_targets))
            
            results = []
            for target in valid_targets:
                result = injector.inject_payload(
                    args.payload,
                    target,
                    method=args.method
                )
                results.append(result)
                progress.advance(task)
        
        # Display results
        from rich.table import Table
        table = Table(title="Injection Results")
        table.add_column("Target", style="cyan")
        table.add_column("Method", style="yellow")
        table.add_column("Status", style="green")
        table.add_column("Details", style="white")
        
        for i, result in enumerate(results):
            status = "[green]Success[/green]" if result["success"] else "[red]Failed[/red]"
            table.add_row(
                valid_targets[i],
                args.method,
                status,
                result.get("message", "")
            )
        
        console.print(table)
        
        # Summary
        successful = sum(1 for r in results if r["success"])
        console.print(f"[bold green]Injection complete: {successful}/{len(results)} successful[/bold green]")
        
        return successful > 0
        
    except Exception as e:
        console.print(f"[bold red]Error during injection: {str(e)}[/bold red]")
        return False

def handle_report_command(args, logger):
    """Handle report generation command"""
    console.print("[cyan]Generating report...[/cyan]")
    
    try:
        from enhancements import ReportGenerator
        report_gen = ReportGenerator(logger)
        
        # Determine data source
        data_dir = args.data or "logs"
        if not os.path.exists(data_dir):
            console.print(f"[bold red]Data directory not found: {data_dir}[/bold red]")
            return False
        
        # Generate report
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        output_file = f"rexploit_report_{timestamp}.{args.format}"
        
        if args.format == "html":
            report_file = report_gen.generate_html_report(data_dir, output_file, args.template)
        elif args.format == "pdf":
            report_file = report_gen.generate_pdf_report(data_dir, output_file, args.template)
        elif args.format == "json":
            report_file = report_gen.generate_json_report(data_dir, output_file)
        elif args.format == "csv":
            report_file = report_gen.generate_csv_report(data_dir, output_file)
        
        console.print(f"[bold green]Report generated: {report_file}[/bold green]")
        console.print(f"[green]Format: {args.format.upper()}[/green]")
        
        return True
        
    except Exception as e:
        console.print(f"[bold red]Error generating report: {str(e)}[/bold red]")
        return False

def handle_config_command(args, config, logger):
    """Handle configuration management command"""
    console.print("[cyan]Managing configuration...[/cyan]")
    
    try:
        if args.show:
            console.print("[bold yellow]Current Configuration:[/bold yellow]")
            
            from rich.table import Table
            table = Table(title="RexPloit Configuration")
            table.add_column("Setting", style="cyan")
            table.add_column("Value", style="green")
            
            for key, value in config.items():
                # Mask sensitive values
                if "password" in key.lower() or "key" in key.lower():
                    value = "*" * len(str(value))
                table.add_row(key, str(value))
            
            console.print(table)
            
        elif args.set:
            key, value = args.set
            config[key] = value
            core.save_config(config)
            console.print(f"[bold green]Configuration updated: {key} = {value}[/bold green]")
            
        elif args.reset:
            if Confirm.ask("Reset configuration to defaults?", default=False):
                default_config = core.get_default_config()
                core.save_config(default_config)
                console.print("[bold green]Configuration reset to defaults[/bold green]")
            else:
                console.print("[yellow]Reset cancelled[/yellow]")
        
        return True
        
    except Exception as e:
        console.print(f"[bold red]Error managing configuration: {str(e)}[/bold red]")
        return False

def handle_legacy_payload(args, payload_gen, logger):
    """Handle legacy payload generation for backward compatibility"""
    console.print("[yellow]Using legacy payload syntax[/yellow]")
    console.print("[cyan]Generating payload...[/cyan]")
    
    try:
        payload_map = {
            "python": "python_reverse_tcp",
            "bash": "bash_reverse_tcp", 
            "powershell": "powershell_reverse_tcp",
            "php": "php_reverse_tcp",
            "perl": "perl_reverse_tcp"
        }
        
        payload_type = payload_map.get(args.legacy_payload)
        if not payload_type:
            console.print(f"[bold red]Unsupported payload type: {args.legacy_payload}[/bold red]")
            return False
        
        lhost = args.legacy_lhost or Prompt.ask("Enter listener host")
        lport = args.legacy_lport or int(Prompt.ask("Enter listener port", default="4444"))
        
        result = payload_gen.generate_payload(
            payload_type=payload_type,
            lhost=lhost,
            lport=lport,
            encode=args.legacy_encode,
            obfuscate=args.legacy_obfuscate
        )
        
        if result["success"]:
            console.print(f"[bold green]Payload generated: {result['file_path']}[/bold green]")
            
            # Display payload content
            with open(result['file_path'], 'r') as f:
                payload_content = f.read()
            
            console.print(Panel(payload_content, title=f"Payload: {args.legacy_payload}", border_style="green"))
            return True
        else:
            console.print(f"[bold red]Payload generation failed: {result.get('error', 'Unknown error')}[/bold red]")
            return False
            
    except Exception as e:
        console.print(f"[bold red]Error generating payload: {str(e)}[/bold red]")
        return False

def handle_legacy_c2(args, c2_manager, logger):
    """Handle legacy C2 command for backward compatibility"""
    console.print("[yellow]Using legacy C2 syntax[/yellow]")
    console.print(f"[cyan]Starting {args.legacy_c2} C2 framework...[/cyan]")
    
    try:
        success = c2_manager.start_framework(args.legacy_c2)
        
        if success:
            console.print(f"[bold green]{args.legacy_c2.capitalize()} C2 framework started[/bold green]")
            console.print("[yellow]Press Ctrl+C to stop the framework[/yellow]")
            
            try:
                while True:
                    import time
                    time.sleep(1)
                    logs = c2_manager.get_logs()
                    for log in logs:
                        console.print(log)
                        
            except KeyboardInterrupt:
                console.print("\n[yellow]Stopping framework...[/yellow]")
                c2_manager.stop_framework()
                console.print("[green]Framework stopped[/green]")
        else:
            console.print(f"[bold red]Failed to start {args.legacy_c2} C2 framework[/bold red]")
            return False
            
        return True
        
    except Exception as e:
        console.print(f"[bold red]Error starting C2 framework: {str(e)}[/bold red]")
        return False

def handle_legacy_scan(args, scanner, logger):
    """Handle legacy scan command for backward compatibility"""
    console.print("[yellow]Using legacy scan syntax[/yellow]")
    console.print(f"[cyan]Scanning target: {args.legacy_scan}[/cyan]")
    
    try:
        from enhancements import TargetValidator
        validator = TargetValidator(logger)
        
        if not validator.validate_target(args.legacy_scan):
            console.print(f"[bold red]Invalid target: {args.legacy_scan}[/bold red]")
            return False
        
        scan_results = scanner.scan_vulnerabilities(args.legacy_scan)
        
        if scan_results:
            console.print(f"[bold green]Vulnerability scan completed[/bold green]")
            
            from rich.table import Table
            table = Table(title="Vulnerability Scan Results")
            table.add_column("Vulnerability", style="red")
            table.add_column("Severity", style="yellow")
            table.add_column("Description", style="cyan")
            
            for vuln in scan_results:
                table.add_row(vuln["name"], vuln["severity"], vuln["description"])
            
            console.print(table)
            
            # Generate report
            from enhancements import ReportGenerator
            report_gen = ReportGenerator(logger)
            
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            report_path = f"scan_report_{timestamp}.json"
            
            with open(report_path, 'w') as f:
                json.dump(scan_results, f, indent=2)
            
            html_report = report_gen.generate_html_report(report_path)
            console.print(f"[green]Report generated: {html_report}[/green]")
            
        else:
            console.print("[yellow]No vulnerabilities found[/yellow]")
        
        return True
        
    except Exception as e:
        console.print(f"[bold red]Error scanning target: {str(e)}[/bold red]")
        return False

def run_interactive_cli(config, logger):
    """Run interactive CLI mode"""
    console.print(Panel.fit(
        "[bold blue]RexPloit Interactive CLI Mode[/bold blue]\n"
        "Type 'help' for available commands or 'exit' to quit",
        title="Interactive Mode",
        border_style="blue"
    ))
    
    # Initialize components
    payload_gen = core.PayloadGenerator(config)
    c2_manager = core.C2Manager(config)
    injector = core.Injector()
    scanner = core.VulnerabilityScanner()
    
    while True:
        try:
            cmd = Prompt.ask("[bold cyan]rexploit[/bold cyan]", default="help")
            cmd_parts = cmd.strip().split()
            
            if not cmd_parts:
                continue
                
            command = cmd_parts[0].lower()
            
            if command in ['exit', 'quit', 'q']:
                console.print("[yellow]Goodbye![/yellow]")
                break
                
            elif command == 'help':
                show_interactive_help()
                
            elif command == 'status':
                show_system_status(config, c2_manager)
                
            elif command == 'payload':
                interactive_payload_generation(payload_gen, cmd_parts[1:])
                
            elif command == 'c2':
                interactive_c2_management(c2_manager, cmd_parts[1:])
                
            elif command == 'scan':
                interactive_scanning(scanner, cmd_parts[1:])
                
            elif command == 'inject':
                interactive_injection(injector, cmd_parts[1:])
                
            elif command == 'config':
                interactive_config_management(config, cmd_parts[1:])
                
            elif command == 'clear':
                os.system('clear' if os.name == 'posix' else 'cls')
                
            else:
                console.print(f"[red]Unknown command: {command}[/red]")
                console.print("Type 'help' for available commands")
                
        except KeyboardInterrupt:
            console.print("\n[yellow]Use 'exit' to quit[/yellow]")
            continue
        except Exception as e:
            console.print(f"[bold red]Error: {str(e)}[/bold red]")
            continue
    
    return True

def show_interactive_help():
    """Show help for interactive mode"""
    console.print("\n[bold yellow]Available Commands:[/bold yellow]")
    
    from rich.table import Table
    table = Table(title="RexPloit Interactive Commands")
    table.add_column("Command", style="cyan")
    table.add_column("Description", style="white")
    table.add_column("Example", style="green")
    
    commands = [
        ("help", "Show this help message", "help"),
        ("status", "Show system status", "status"),
        ("payload", "Generate payloads", "payload python 192.168.1.100 4444"),
        ("c2", "Manage C2 frameworks", "c2 start sliver"),
        ("scan", "Perform security scans", "scan vuln 192.168.1.100"),
        ("inject", "Deploy payloads", "inject payload.py target1 target2"),
        ("config", "Manage configuration", "config show"),
        ("clear", "Clear screen", "clear"),
        ("exit/quit/q", "Exit interactive mode", "exit")
    ]
    
    for cmd, desc, example in commands:
        table.add_row(cmd, desc, example)
    
    console.print(table)
    console.print("\n[yellow]For detailed help on a command, type: <command> --help[/yellow]")

def show_system_status(config, c2_manager):
    """Show current system status"""
    console.print("\n[bold blue]System Status:[/bold blue]")
    
    from rich.table import Table
    table = Table(title="RexPloit System Status")
    table.add_column("Component", style="cyan")
    table.add_column("Status", style="green")
    table.add_column("Details", style="white")
    
    # Check C2 framework status
    try:
        c2_status = c2_manager.get_status()
        if c2_status["active"]:
            table.add_row("C2 Framework", "[green]Running[/green]", f"PID: {c2_status.get('pid', 'Unknown')}")
        else:
            table.add_row("C2 Framework", "[yellow]Stopped[/yellow]", "Not running")
    except:
        table.add_row("C2 Framework", "[red]Error[/red]", "Cannot determine status")
    
    # Check directories
    dirs_to_check = [core.PAYLOAD_DIR, core.LOG_DIR, core.C2_DIR]
    for dir_path in dirs_to_check:
        if os.path.exists(dir_path):
            file_count = len(os.listdir(dir_path))
            table.add_row(f"Directory {dir_path}", "[green]Exists[/green]", f"{file_count} files")
        else:
            table.add_row(f"Directory {dir_path}", "[yellow]Missing[/yellow]", "Will be created")
    
    # Check config
    if config:
        table.add_row("Configuration", "[green]Loaded[/green]", f"{len(config)} settings")
    else:
        table.add_row("Configuration", "[red]Missing[/red]", "No config loaded")
    
    console.print(table)

def interactive_payload_generation(payload_gen, args):
    """Interactive payload generation"""
    if not args:
        payload_type = Prompt.ask("Payload type", choices=["python", "bash", "powershell", "php", "perl"])
        lhost = Prompt.ask("Listener host")
        lport = int(Prompt.ask("Listener port", default="4444"))
        encode = Confirm.ask("Encode payload?", default=False)
        obfuscate = Confirm.ask("Obfuscate payload?", default=False)
    else:
        # Parse arguments
        try:
            payload_type = args[0]
            lhost = args[1]
            lport = int(args[2])
            encode = "--encode" in args
            obfuscate = "--obfuscate" in args
        except (IndexError, ValueError):
            console.print("[red]Usage: payload <type> <lhost> <lport> [--encode] [--obfuscate][/red]")
            return
    
    # Generate payload
    try:
        payload_map = {
            "python": "python_reverse_tcp",
            "bash": "bash_reverse_tcp",
            "powershell": "powershell_reverse_tcp", 
            "php": "php_reverse_tcp",
            "perl": "perl_reverse_tcp"
        }
        
        payload_type_internal = payload_map.get(payload_type)
        if not payload_type_internal:
            console.print(f"[red]Unsupported payload type: {payload_type}[/red]")
            return
        
        result = payload_gen.generate_payload(
            payload_type=payload_type_internal,
            lhost=lhost,
            lport=lport,
            encode=encode,
            obfuscate=obfuscate
        )
        
        if result["success"]:
            console.print(f"[bold green]Payload generated: {result['file_path']}[/bold green]")
            
            # Show preview if small
            if os.path.getsize(result['file_path']) < 512:
                with open(result['file_path'], 'r') as f:
                    content = f.read()
                from rich.syntax import Syntax
                syntax = Syntax(content, payload_type, theme="monokai", line_numbers=True)
                console.print(Panel(syntax, title="Payload Preview"))
        else:
            console.print(f"[red]Failed to generate payload: {result.get('error', 'Unknown error')}[/red]")
            
    except Exception as e:
        console.print(f"[red]Error: {str(e)}[/red]")

def interactive_c2_management(c2_manager, args):
    """Interactive C2 framework management"""
    if not args:
        action = Prompt.ask("Action", choices=["start", "stop", "status"])
        if action in ["start", "stop"]:
            framework = Prompt.ask("Framework", choices=["sliver", "villain", "hoaxshell"])
    else:
        try:
            action = args[0]
            framework = args[1] if len(args) > 1 else None
        except IndexError:
            console.print("[red]Usage: c2 <start|stop|status> [framework][/red]")
            return
    
    try:
        if action == "start":
            if not framework:
                framework = Prompt.ask("Framework", choices=["sliver", "villain", "hoaxshell"])
            
            console.print(f"[cyan]Starting {framework}...[/cyan]")
            success = c2_manager.start_framework(framework)
            
            if success:
                console.print(f"[green]{framework.capitalize()} started successfully[/green]")
            else:
                console.print(f"[red]Failed to start {framework}[/red]")
                
        elif action == "stop":
            console.print("[cyan]Stopping C2 framework...[/cyan]")
            success = c2_manager.stop_framework()
            
            if success:
                console.print("[green]C2 framework stopped[/green]")
            else:
                console.print("[red]Failed to stop C2 framework[/red]")
                
        elif action == "status":
            status = c2_manager.get_status()
            
            from rich.table import Table
            table = Table(title="C2 Framework Status")
            table.add_column("Property", style="cyan")
            table.add_column("Value", style="green")
            
            table.add_row("Active", str(status.get("active", False)))
            table.add_row("PID", str(status.get("pid", "N/A")))
            table.add_row("Listeners", str(status.get("listeners", 0)))
            table.add_row("Sessions", str(status.get("sessions", 0)))
            
            console.print(table)
            
    except Exception as e:
        console.print(f"[red]Error: {str(e)}[/red]")

def interactive_scanning(scanner, args):
    """Interactive vulnerability scanning"""
    if not args:
        scan_type = Prompt.ask("Scan type", choices=["vuln", "network", "port"], default="vuln")
        target = Prompt.ask("Target")
    else:
        try:
            scan_type = args[0]
            target = args[1]
        except IndexError:
            console.print("[red]Usage: scan <type> <target>[/red]")
            return
    
    try:
        from enhancements import TargetValidator
        validator = TargetValidator()
        
        if not validator.validate_target(target):
            console.print(f"[red]Invalid target: {target}[/red]")
            return
        
        console.print(f"[cyan]Running {scan_type} scan on {target}...[/cyan]")
        
        if scan_type == "vuln":
            results = scanner.scan_vulnerabilities(target)
        elif scan_type == "network":
            from enhancements import NetworkScanner
            net_scanner = NetworkScanner()
            results = net_scanner.scan_network(target)
        elif scan_type == "port":
            results = scanner.scan_ports(target)
        
        if results:
            from rich.table import Table
            table = Table(title=f"{scan_type.capitalize()} Scan Results")
            
            if scan_type == "vuln":
                table.add_column("Vulnerability", style="red")
                table.add_column("Severity", style="yellow")
                table.add_column("Description", style="cyan")
                
                for vuln in results:
                    table.add_row(vuln["name"], vuln["severity"], vuln["description"])
            else:
                table.add_column("Host", style="green")
                table.add_column("Port", style="cyan")
                table.add_column("Service", style="yellow")
                table.add_column("Status", style="red")
                
                for result in results:
                    table.add_row(
                        result.get("host", ""),
                        str(result.get("port", "")),
                        result.get("service", ""),
                        result.get("status", "")
                    )
            
            console.print(table)
        else:
            console.print("[yellow]No results found[/yellow]")
            
    except Exception as e:
        console.print(f"[red]Error: {str(e)}[/red]")

def interactive_injection(injector, args):
    """Interactive payload injection"""
    if not args:
        payload_file = Prompt.ask("Payload file")
        targets = Prompt.ask("Targets (space-separated)").split()
        method = Prompt.ask("Injection method", choices=["ssh", "smb", "http"], default="ssh")
    else:
        try:
            payload_file = args[0]
            targets = args[1:]
            method = "ssh"  # Default method
        except IndexError:
            console.print("[red]Usage: inject <payload_file> <target1> [target2] ...[/red]")
            return
    
    try:
        if not os.path.exists(payload_file):
            console.print(f"[red]Payload file not found: {payload_file}[/red]")
            return
        
        console.print(f"[cyan]Injecting {payload_file} to {len(targets)} target(s)...[/cyan]")
        
        results = []
        for target in targets:
            result = injector.inject_payload(payload_file, target, method=method)
            results.append((target, result))
        
        # Display results
        from rich.table import Table
        table = Table(title="Injection Results")
        table.add_column("Target", style="cyan")
        table.add_column("Status", style="green")
        table.add_column("Details", style="white")
        
        for target, result in results:
            status = "[green]Success[/green]" if result["success"] else "[red]Failed[/red]"
            table.add_row(target, status, result.get("message", ""))
        
        console.print(table)
        
    except Exception as e:
        console.print(f"[red]Error: {str(e)}[/red]")

def interactive_config_management(config, args):
    """Interactive configuration management"""
    if not args:
        action = Prompt.ask("Action", choices=["show", "set", "reset"])
    else:
        action = args[0]
    
    try:
        if action == "show":
            from rich.table import Table
            table = Table(title="Configuration")
            table.add_column("Setting", style="cyan")
            table.add_column("Value", style="green")
            
            for key, value in config.items():
                if "password" in key.lower() or "key" in key.lower():
                    value = "*" * len(str(value))
                table.add_row(key, str(value))
            
            console.print(table)
            
        elif action == "set":
            if len(args) >= 3:
                key, value = args[1], args[2]
            else:
                key = Prompt.ask("Setting name")
                value = Prompt.ask("Setting value")
            
            config[key] = value
            core.save_config(config)
            console.print(f"[green]Updated {key} = {value}[/green]")
            
        elif action == "reset":
            if Confirm.ask("Reset all configuration to defaults?", default=False):
                default_config = core.get_default_config()
                core.save_config(default_config)
                console.print("[green]Configuration reset to defaults[/green]")
            
    except Exception as e:
        console.print(f"[red]Error: {str(e)}[/red]")

def run_tests(logger):
    """Run all tests to validate framework"""
    logger.info("Running RexPloit test suite")
    
    console.print("[bold blue]Starting RexPloit Test Suite[/bold blue]")
    
    try:
        # Import and run tests
        from run_tests import main as run_test_main
        
        # Run all tests
        run_test_main(["--all"])
        
        return True
    except Exception as e:
        console.print(f"[bold red]Error running tests: {str(e)}[/bold red]")
        return False

def main():
    """Main entry point for unified RexPloit framework"""
    # Setup logging first
    logger = setup_logging()
    logger.info(f"Starting RexPloit v{VERSION} ({CODENAME})")
    
    # Parse arguments (this will handle --help and --version properly)
    args = parse_arguments()
    
    # Enable debug logging if requested
    if args.debug:
        logger.setLevel(logging.DEBUG)
        logger.debug("Debug logging enabled")
    
    # Display banner
    show_banner()
    
    # Check for command-line specific options
    if args.install:
        return check_dependencies(install=True)
    
    if args.check:
        return check_dependencies(install=False)
        
    # Check authorization
    if not check_authorization():
        console.print("[bold red]Access denied. Authorization required.[/bold red]")
        logger.warning("Authorization check failed")
        return False
        
    # Dependency check
    if not check_dependencies():
        console.print("[bold red]Critical dependencies missing. Cannot continue.[/bold red]")
        logger.error("Critical dependencies missing")
        return False
    
    # Run tests if requested
    if args.test:
        return run_tests(logger)
        
    # Always run in CLI mode - TUI/GUI modes have been removed
    return handle_cli_mode(args, logger)

if __name__ == "__main__":
    try:
        success = main()
        sys.exit(0 if success else 1)
    except KeyboardInterrupt:
        console.print("\n[yellow]Operation cancelled by user[/yellow]")
        sys.exit(0)
    except Exception as e:
        console.print(f"[bold red]Fatal error: {str(e)}[/bold red]")
        sys.exit(1)