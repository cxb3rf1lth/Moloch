#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
RexPloit - Master Unified Framework
Professional Penetration Testing Tool with Advanced Features
For authorized security testing only
"""

import os
import sys
import argparse
import logging
import textwrap
import json
from datetime import datetime
from rich.console import Console
from rich.panel import Panel
from rich.prompt import Confirm, Prompt
from rich.progress import Progress, SpinnerColumn, TextColumn
from rich import print as rprint

# Import RexPloit modules
from dependency_manager import DependencyManager
import rexploit_core as core
import enhancements

# Version info
VERSION = "2.0.0"
CODENAME = "Cerberus"

# Setup console for rich output
console = Console()

def setup_logging():
    """Configure logging for the application"""
    log_format = "[%(asctime)s] [%(levelname)s] %(message)s"
    date_format = "%Y-%m-%d %H:%M:%S"
    
    # Create logs directory if it doesn't exist
    os.makedirs("logs", exist_ok=True)
    
    # Configure root logger
    logging.basicConfig(
        level=logging.INFO,
        format=log_format,
        datefmt=date_format,
        handlers=[
            logging.FileHandler("logs/rexploit_unified.log"),
            logging.StreamHandler()
        ]
    )
    
    return logging.getLogger("rexploit")

def show_banner():
    """Display RexPloit banner"""
    banner = f"""
    ██████╗ ███████╗██╗  ██╗██████╗ ██╗      ██████╗ ██╗████████╗
    ██╔══██╗██╔════╝╚██╗██╔╝██╔══██╗██║     ██╔═══██╗██║╚══██╔══╝
    ██████╔╝█████╗   ╚███╔╝ ██████╔╝██║     ██║   ██║██║   ██║   
    ██╔══██╗██╔══╝   ██╔██╗ ██╔═══╝ ██║     ██║   ██║██║   ██║   
    ██║  ██║███████╗██╔╝ ██╗██║     ███████╗╚██████╔╝██║   ██║   
    ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚═╝     ╚══════╝ ╚═════╝ ╚═╝   ╚═╝   
                                                              
    v{VERSION} "{CODENAME}" - Professional Penetration Testing Framework
    FOR AUTHORIZED SECURITY TESTING ONLY
    """
    
    console.print(Panel(banner, style="bold blue", border_style="blue"))
    console.print("\n[bold yellow]WARNING: Use responsibly and only on systems you have permission to test.[/bold yellow]\n")

def check_authorization():
    """Verify user has authorization to use the tool"""
    console.print("[bold]Authorization Required[/bold]")
    console.print("This tool is for professional security testing only.")
    console.print("You must have explicit permission to test the target systems.")
    
    return Confirm.ask("Do you have proper authorization for all targets?", default=False)
    
def check_dependencies(install=False):
    """Check and install dependencies if needed"""
    console.print("[bold blue]Checking dependencies...[/bold blue]")
    
    try:
        manager = DependencyManager()
        
        if install:
            result = manager.check_all_dependencies(auto_install=True)
            if not result:
                console.print("[bold yellow]Some dependencies could not be installed.[/bold yellow]")
                console.print("You may need to install them manually.")
            return result
        else:
            result = manager.check_all_dependencies(auto_install=False)
            if not result:
                if Confirm.ask("Install missing dependencies now?", default=True):
                    return manager.check_all_dependencies(auto_install=True)
                else:
                    console.print("[bold yellow]Some dependencies are missing.[/bold yellow]")
                    console.print("The tool may not function correctly without them.")
            return result
    except Exception as e:
        console.print(f"[bold red]Error checking dependencies: {str(e)}[/bold red]")
        return False
        
def parse_arguments():
    """Parse command-line arguments with enhanced CLI support"""
    parser = argparse.ArgumentParser(
        prog='rexploit',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description=textwrap.dedent(f'''
        RexPloit v{VERSION} "{CODENAME}" - Professional Penetration Testing Framework
        For authorized security testing only
        
        This tool provides comprehensive penetration testing capabilities including:
        - C2 framework management (Sliver, Villain, HoaxShell)
        - Payload generation and deployment
        - Vulnerability scanning
        - Network reconnaissance
        - Security reporting
        '''),
        epilog=textwrap.dedent('''
        Examples:
          rexploit --cli payload --type python --lhost 192.168.1.100 --lport 4444
          rexploit --cli c2 --framework sliver --start
          rexploit --cli scan --target 192.168.1.0/24
          rexploit --cli report --format html --output /tmp/report.html
        
        For interactive mode, simply run: rexploit --cli
        ''')
    )
    
    # Main mode arguments
    parser.add_argument("--cli", action="store_true", 
                      help="Run in CLI mode (default behavior)")
    parser.add_argument("--interactive", action="store_true",
                      help="Run in interactive CLI mode")
    parser.add_argument("--install", action="store_true", 
                      help="Install missing dependencies")
    parser.add_argument("--check", action="store_true", 
                      help="Check dependencies without installing")
    parser.add_argument("--test", action="store_true", 
                      help="Run test suite")
    parser.add_argument("--debug", action="store_true", 
                      help="Enable debug logging")
    parser.add_argument("--config", metavar="FILE", 
                      help="Use alternative config file")
    parser.add_argument("--output", metavar="DIR", 
                      help="Output directory for reports and payloads")
    parser.add_argument("--version", action="version", 
                      version=f"RexPloit v{VERSION} ({CODENAME})")
    
    # Create subparsers for different operations
    subparsers = parser.add_subparsers(dest='command', help='Available commands')
    
    # Payload generation subcommand
    payload_parser = subparsers.add_parser('payload', help='Generate payloads')
    payload_parser.add_argument("--type", choices=["python", "bash", "powershell", "php", "perl"], 
                              help="Payload type to generate", required=True)
    payload_parser.add_argument("--lhost", help="Listener host", required=True)
    payload_parser.add_argument("--lport", type=int, help="Listener port", required=True)
    payload_parser.add_argument("--encode", action="store_true", help="Encode payload")
    payload_parser.add_argument("--obfuscate", action="store_true", help="Obfuscate payload")
    payload_parser.add_argument("--output-file", help="Output file for payload")
    
    # C2 framework subcommand
    c2_parser = subparsers.add_parser('c2', help='Manage C2 frameworks')
    c2_parser.add_argument("--framework", choices=["sliver", "villain", "hoaxshell"], 
                         help="C2 framework to use", required=True)
    c2_group = c2_parser.add_mutually_exclusive_group(required=True)
    c2_group.add_argument("--start", action="store_true", help="Start C2 framework")
    c2_group.add_argument("--stop", action="store_true", help="Stop C2 framework")
    c2_group.add_argument("--status", action="store_true", help="Check C2 framework status")
    
    # Scanning subcommand
    scan_parser = subparsers.add_parser('scan', help='Perform security scans')
    scan_parser.add_argument("--target", help="Target to scan", required=True)
    scan_parser.add_argument("--type", choices=["vuln", "network", "port"], 
                           default="vuln", help="Type of scan to perform")
    scan_parser.add_argument("--threads", type=int, default=10, help="Number of threads")
    scan_parser.add_argument("--timeout", type=int, default=30, help="Scan timeout")
    
    # Injection subcommand
    inject_parser = subparsers.add_parser('inject', help='Deploy payloads')
    inject_parser.add_argument("--payload", help="Payload file to deploy", required=True)
    inject_parser.add_argument("--targets", nargs="+", help="Target systems", required=True)
    inject_parser.add_argument("--method", choices=["ssh", "smb", "http"], 
                             default="ssh", help="Injection method")
    
    # Reporting subcommand
    report_parser = subparsers.add_parser('report', help='Generate reports')
    report_parser.add_argument("--format", choices=["html", "pdf", "json", "csv"], 
                             default="html", help="Report format")
    report_parser.add_argument("--template", help="Report template file")
    report_parser.add_argument("--data", help="Data directory or file for report")
    
    # Configuration subcommand
    config_parser = subparsers.add_parser('config', help='Manage configuration')
    config_group = config_parser.add_mutually_exclusive_group(required=True)
    config_group.add_argument("--show", action="store_true", help="Show current configuration")
    config_group.add_argument("--set", nargs=2, metavar=("KEY", "VALUE"), help="Set configuration value")
    config_group.add_argument("--reset", action="store_true", help="Reset to default configuration")
    
    # Legacy compatibility arguments (for backward compatibility)
    parser.add_argument("--legacy", action="store_true", help=argparse.SUPPRESS)
    parser.add_argument("--payload", dest="legacy_payload", 
                      choices=["python", "bash", "powershell", "php", "perl"], 
                      help=argparse.SUPPRESS)
    parser.add_argument("--lhost", dest="legacy_lhost", help=argparse.SUPPRESS)
    parser.add_argument("--lport", dest="legacy_lport", type=int, help=argparse.SUPPRESS)
    parser.add_argument("--c2", dest="legacy_c2", 
                      choices=["sliver", "villain", "hoaxshell"], help=argparse.SUPPRESS)
    parser.add_argument("--scan", dest="legacy_scan", metavar="TARGET", help=argparse.SUPPRESS)
    parser.add_argument("--encode", dest="legacy_encode", action="store_true", help=argparse.SUPPRESS)
    parser.add_argument("--obfuscate", dest="legacy_obfuscate", action="store_true", help=argparse.SUPPRESS)
    
    return parser.parse_args()

def handle_cli_mode(args, logger):
    """Handle enhanced command-line interface mode"""
    logger.info("Starting RexPloit in professional CLI mode")
    
    # Load configuration
    config = core.load_config()
    
    # Override config with command-line arguments
    if args.legacy_lhost:
        config["listener_host"] = args.legacy_lhost
    if args.legacy_lport:
        config["listener_port"] = args.legacy_lport
    if args.legacy_c2:
        config["default_c2"] = args.legacy_c2
    if args.output:
        core.PAYLOAD_DIR = args.output
        core.LOG_DIR = os.path.join(args.output, "logs")
    
    # Initialize components
    logger = core.Logger()
    payload_gen = core.PayloadGenerator(config)
    c2_manager = core.C2Manager(config)
    injector = core.Injector()
    scanner = core.VulnerabilityScanner()
    
    # Handle subcommands
    if args.command == 'payload':
        return handle_payload_command(args, payload_gen, logger)
    elif args.command == 'c2':
        return handle_c2_command(args, c2_manager, logger)
    elif args.command == 'scan':
        return handle_scan_command(args, scanner, logger)
    elif args.command == 'inject':
        return handle_inject_command(args, injector, logger)
    elif args.command == 'report':
        return handle_report_command(args, logger)
    elif args.command == 'config':
        return handle_config_command(args, config, logger)
    
    # Handle legacy single-argument commands for backward compatibility
    elif args.legacy_payload:
        return handle_legacy_payload(args, payload_gen, logger)
    elif args.legacy_c2:
        return handle_legacy_c2(args, c2_manager, logger)
    elif args.legacy_scan:
        return handle_legacy_scan(args, scanner, logger)
    
    # Default: run interactive mode
    else:
        return run_interactive_cli(config, logger)

def handle_payload_command(args, payload_gen, logger):
    """Handle payload generation command"""
    console.print("[cyan]Generating payload...[/cyan]")
    
    try:
        # Map CLI arguments to internal payload types
        payload_map = {
            "python": "python_reverse_tcp",
            "bash": "bash_reverse_tcp",
            "powershell": "powershell_reverse_tcp",
            "php": "php_reverse_tcp",
            "perl": "perl_reverse_tcp"
        }
        
        payload_type = payload_map.get(args.type)
        if not payload_type:
            console.print(f"[bold red]Unsupported payload type: {args.type}[/bold red]")
            return False
        
        # Generate payload
        result = payload_gen.generate_payload(
            payload_type=payload_type,
            lhost=args.lhost,
            lport=args.lport,
            encode=args.encode,
            obfuscate=args.obfuscate
        )
        
        if result["success"]:
            console.print(f"[bold green]Payload generated successfully[/bold green]")
            console.print(f"[green]File: {result['file_path']}[/green]")
            console.print(f"[green]Type: {args.type}[/green]")
            console.print(f"[green]Host: {args.lhost}:{args.lport}[/green]")
            
            if args.output_file:
                import shutil
                shutil.copy2(result['file_path'], args.output_file)
                console.print(f"[green]Copied to: {args.output_file}[/green]")
            
            # Show payload content if it's short
            if os.path.getsize(result['file_path']) < 1024:
                console.print("\n[bold yellow]Payload Preview:[/bold yellow]")
                with open(result['file_path'], 'r') as f:
                    content = f.read()
                    from rich.syntax import Syntax
                    syntax = Syntax(content, args.type, theme="monokai", line_numbers=True)
                    console.print(syntax)
            
            return True
        else:
            console.print(f"[bold red]Payload generation failed: {result.get('error', 'Unknown error')}[/bold red]")
            return False
            
    except Exception as e:
        console.print(f"[bold red]Error generating payload: {str(e)}[/bold red]")
        return False

def handle_c2_command(args, c2_manager, logger):
    """Handle C2 framework management command"""
    console.print(f"[cyan]Managing {args.framework} C2 framework...[/cyan]")
    
    try:
        if args.start:
            console.print(f"[cyan]Starting {args.framework} C2 framework...[/cyan]")
            success = c2_manager.start_framework(args.framework)
            
            if success:
                console.print(f"[bold green]{args.framework.capitalize()} C2 framework started successfully[/bold green]")
                console.print("[yellow]Press Ctrl+C to stop the framework[/yellow]")
                
                try:
                    # Keep running and show logs
                    while True:
                        import time
                        time.sleep(1)
                        
                        # Show any new logs
                        logs = c2_manager.get_logs()
                        for log in logs:
                            console.print(log)
                            
                except KeyboardInterrupt:
                    console.print("\n[yellow]Stopping framework...[/yellow]")
                    c2_manager.stop_framework()
                    console.print("[green]Framework stopped[/green]")
            else:
                console.print(f"[bold red]Failed to start {args.framework} C2 framework[/bold red]")
                return False
                
        elif args.stop:
            console.print(f"[cyan]Stopping {args.framework} C2 framework...[/cyan]")
            success = c2_manager.stop_framework()
            
            if success:
                console.print(f"[bold green]{args.framework.capitalize()} C2 framework stopped[/bold green]")
            else:
                console.print(f"[bold red]Failed to stop {args.framework} C2 framework[/bold red]")
                return False
                
        elif args.status:
            console.print(f"[cyan]Checking {args.framework} C2 framework status...[/cyan]")
            status = c2_manager.get_status()
            
            if status["active"]:
                console.print(f"[bold green]{args.framework.capitalize()} is running[/bold green]")
                console.print(f"[green]PID: {status.get('pid', 'Unknown')}[/green]")
                console.print(f"[green]Listeners: {status.get('listeners', 0)}[/green]")
                console.print(f"[green]Sessions: {status.get('sessions', 0)}[/green]")
            else:
                console.print(f"[bold yellow]{args.framework.capitalize()} is not running[/bold yellow]")
        
        return True
        
    except Exception as e:
        console.print(f"[bold red]Error managing C2 framework: {str(e)}[/bold red]")
        return False

def handle_scan_command(args, scanner, logger):
    """Handle scanning command"""
    console.print(f"[cyan]Scanning target: {args.target}[/cyan]")
    
    try:
        # Validate target
        from enhancements import TargetValidator
        validator = TargetValidator(logger)
        
        if not validator.validate_target(args.target):
            console.print(f"[bold red]Invalid target: {args.target}[/bold red]")
            return False
        
        # Run scan based on type
        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            console=console
        ) as progress:
            
            if args.type == "vuln":
                task = progress.add_task("Running vulnerability scan...", total=None)
                scan_results = scanner.scan_vulnerabilities(
                    args.target, 
                    threads=args.threads,
                    timeout=args.timeout
                )
            elif args.type == "network":
                task = progress.add_task("Running network scan...", total=None)
                from enhancements import NetworkScanner
                net_scanner = NetworkScanner(logger)
                scan_results = net_scanner.scan_network(args.target)
            elif args.type == "port":
                task = progress.add_task("Running port scan...", total=None)
                scan_results = scanner.scan_ports(
                    args.target,
                    timeout=args.timeout
                )
            
            progress.remove_task(task)
        
        # Display results
        if scan_results:
            console.print(f"[bold green]Scan completed successfully[/bold green]")
            
            # Create results table
            from rich.table import Table
            table = Table(title=f"{args.type.capitalize()} Scan Results")
            
            if args.type == "vuln":
                table.add_column("Vulnerability", style="red")
                table.add_column("Severity", style="yellow")
                table.add_column("Description", style="cyan")
                
                for vuln in scan_results:
                    table.add_row(vuln["name"], vuln["severity"], vuln["description"])
                    
            elif args.type in ["network", "port"]:
                table.add_column("Host", style="green")
                table.add_column("Port", style="cyan")
                table.add_column("Service", style="yellow")
                table.add_column("Status", style="red")
                
                for result in scan_results:
                    table.add_row(
                        result.get("host", ""),
                        str(result.get("port", "")),
                        result.get("service", ""),
                        result.get("status", "")
                    )
            
            console.print(table)
            
            # Save results
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            results_file = f"scan_results_{args.type}_{timestamp}.json"
            
            with open(results_file, 'w') as f:
                json.dump(scan_results, f, indent=2)
            
            console.print(f"[green]Results saved to: {results_file}[/green]")
            return True
        else:
            console.print("[yellow]No results found[/yellow]")
            return True
            
    except Exception as e:
        console.print(f"[bold red]Error during scan: {str(e)}[/bold red]")
        return False

def handle_inject_command(args, injector, logger):
    """Handle payload injection command"""
    console.print(f"[cyan]Deploying payload: {args.payload}[/cyan]")
    
    try:
        # Validate payload file exists
        if not os.path.exists(args.payload):
            console.print(f"[bold red]Payload file not found: {args.payload}[/bold red]")
            return False
        
        # Validate targets
        from enhancements import TargetValidator
        validator = TargetValidator(logger)
        valid_targets = []
        
        for target in args.targets:
            if validator.validate_target(target):
                valid_targets.append(target)
            else:
                console.print(f"[yellow]Skipping invalid target: {target}[/yellow]")
        
        if not valid_targets:
            console.print("[bold red]No valid targets found[/bold red]")
            return False
        
        console.print(f"[green]Deploying to {len(valid_targets)} target(s)[/green]")
        
        # Deploy payload
        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            console=console
        ) as progress:
            
            task = progress.add_task("Deploying payload...", total=len(valid_targets))
            
            results = []
            for target in valid_targets:
                result = injector.inject_payload(
                    args.payload,
                    target,
                    method=args.method
                )
                results.append(result)
                progress.advance(task)
        
        # Display results
        from rich.table import Table
        table = Table(title="Injection Results")
        table.add_column("Target", style="cyan")
        table.add_column("Method", style="yellow")
        table.add_column("Status", style="green")
        table.add_column("Details", style="white")
        
        for i, result in enumerate(results):
            status = "[green]Success[/green]" if result["success"] else "[red]Failed[/red]"
            table.add_row(
                valid_targets[i],
                args.method,
                status,
                result.get("message", "")
            )
        
        console.print(table)
        
        # Summary
        successful = sum(1 for r in results if r["success"])
        console.print(f"[bold green]Injection complete: {successful}/{len(results)} successful[/bold green]")
        
        return successful > 0
        
    except Exception as e:
        console.print(f"[bold red]Error during injection: {str(e)}[/bold red]")
        return False

def handle_report_command(args, logger):
    """Handle report generation command"""
    console.print("[cyan]Generating report...[/cyan]")
    
    try:
        from enhancements import ReportGenerator
        report_gen = ReportGenerator(logger)
        
        # Determine data source
        data_dir = args.data or "logs"
        if not os.path.exists(data_dir):
            console.print(f"[bold red]Data directory not found: {data_dir}[/bold red]")
            return False
        
        # Generate report
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        output_file = f"rexploit_report_{timestamp}.{args.format}"
        
        if args.format == "html":
            report_file = report_gen.generate_html_report(data_dir, output_file, args.template)
        elif args.format == "pdf":
            report_file = report_gen.generate_pdf_report(data_dir, output_file, args.template)
        elif args.format == "json":
            report_file = report_gen.generate_json_report(data_dir, output_file)
        elif args.format == "csv":
            report_file = report_gen.generate_csv_report(data_dir, output_file)
        
        console.print(f"[bold green]Report generated: {report_file}[/bold green]")
        console.print(f"[green]Format: {args.format.upper()}[/green]")
        
        return True
        
    except Exception as e:
        console.print(f"[bold red]Error generating report: {str(e)}[/bold red]")
        return False

def handle_config_command(args, config, logger):
    """Handle configuration management command"""
    console.print("[cyan]Managing configuration...[/cyan]")
    
    try:
        if args.show:
            console.print("[bold yellow]Current Configuration:[/bold yellow]")
            
            from rich.table import Table
            table = Table(title="RexPloit Configuration")
            table.add_column("Setting", style="cyan")
            table.add_column("Value", style="green")
            
            for key, value in config.items():
                # Mask sensitive values
                if "password" in key.lower() or "key" in key.lower():
                    value = "*" * len(str(value))
                table.add_row(key, str(value))
            
            console.print(table)
            
        elif args.set:
            key, value = args.set
            config[key] = value
            core.save_config(config)
            console.print(f"[bold green]Configuration updated: {key} = {value}[/bold green]")
            
        elif args.reset:
            if Confirm.ask("Reset configuration to defaults?", default=False):
                default_config = core.get_default_config()
                core.save_config(default_config)
                console.print("[bold green]Configuration reset to defaults[/bold green]")
            else:
                console.print("[yellow]Reset cancelled[/yellow]")
        
        return True
        
    except Exception as e:
        console.print(f"[bold red]Error managing configuration: {str(e)}[/bold red]")
        return False

def handle_legacy_payload(args, payload_gen, logger):
    """Handle legacy payload generation for backward compatibility"""
    console.print("[yellow]Using legacy payload syntax[/yellow]")
    console.print("[cyan]Generating payload...[/cyan]")
    
    try:
        payload_map = {
            "python": "python_reverse_tcp",
            "bash": "bash_reverse_tcp", 
            "powershell": "powershell_reverse_tcp",
            "php": "php_reverse_tcp",
            "perl": "perl_reverse_tcp"
        }
        
        payload_type = payload_map.get(args.legacy_payload)
        if not payload_type:
            console.print(f"[bold red]Unsupported payload type: {args.legacy_payload}[/bold red]")
            return False
        
        lhost = args.legacy_lhost or Prompt.ask("Enter listener host")
        lport = args.legacy_lport or int(Prompt.ask("Enter listener port", default="4444"))
        
        result = payload_gen.generate_payload(
            payload_type=payload_type,
            lhost=lhost,
            lport=lport,
            encode=args.legacy_encode,
            obfuscate=args.legacy_obfuscate
        )
        
        if result["success"]:
            console.print(f"[bold green]Payload generated: {result['file_path']}[/bold green]")
            
            # Display payload content
            with open(result['file_path'], 'r') as f:
                payload_content = f.read()
            
            console.print(Panel(payload_content, title=f"Payload: {args.legacy_payload}", border_style="green"))
            return True
        else:
            console.print(f"[bold red]Payload generation failed: {result.get('error', 'Unknown error')}[/bold red]")
            return False
            
    except Exception as e:
        console.print(f"[bold red]Error generating payload: {str(e)}[/bold red]")
        return False

def handle_legacy_c2(args, c2_manager, logger):
    """Handle legacy C2 command for backward compatibility"""
    console.print("[yellow]Using legacy C2 syntax[/yellow]")
    console.print(f"[cyan]Starting {args.legacy_c2} C2 framework...[/cyan]")
    
    try:
        success = c2_manager.start_framework(args.legacy_c2)
        
        if success:
            console.print(f"[bold green]{args.legacy_c2.capitalize()} C2 framework started[/bold green]")
            console.print("[yellow]Press Ctrl+C to stop the framework[/yellow]")
            
            try:
                while True:
                    import time
                    time.sleep(1)
                    logs = c2_manager.get_logs()
                    for log in logs:
                        console.print(log)
                        
            except KeyboardInterrupt:
                console.print("\n[yellow]Stopping framework...[/yellow]")
                c2_manager.stop_framework()
                console.print("[green]Framework stopped[/green]")
        else:
            console.print(f"[bold red]Failed to start {args.legacy_c2} C2 framework[/bold red]")
            return False
            
        return True
        
    except Exception as e:
        console.print(f"[bold red]Error starting C2 framework: {str(e)}[/bold red]")
        return False

def handle_legacy_scan(args, scanner, logger):
    """Handle legacy scan command for backward compatibility"""
    console.print("[yellow]Using legacy scan syntax[/yellow]")
    console.print(f"[cyan]Scanning target: {args.legacy_scan}[/cyan]")
    
    try:
        from enhancements import TargetValidator
        validator = TargetValidator(logger)
        
        if not validator.validate_target(args.legacy_scan):
            console.print(f"[bold red]Invalid target: {args.legacy_scan}[/bold red]")
            return False
        
        scan_results = scanner.scan_vulnerabilities(args.legacy_scan)
        
        if scan_results:
            console.print(f"[bold green]Vulnerability scan completed[/bold green]")
            
            from rich.table import Table
            table = Table(title="Vulnerability Scan Results")
            table.add_column("Vulnerability", style="red")
            table.add_column("Severity", style="yellow")
            table.add_column("Description", style="cyan")
            
            for vuln in scan_results:
                table.add_row(vuln["name"], vuln["severity"], vuln["description"])
            
            console.print(table)
            
            # Generate report
            from enhancements import ReportGenerator
            report_gen = ReportGenerator(logger)
            
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            report_path = f"scan_report_{timestamp}.json"
            
            with open(report_path, 'w') as f:
                json.dump(scan_results, f, indent=2)
            
            html_report = report_gen.generate_html_report(report_path)
            console.print(f"[green]Report generated: {html_report}[/green]")
            
        else:
            console.print("[yellow]No vulnerabilities found[/yellow]")
        
        return True
        
    except Exception as e:
        console.print(f"[bold red]Error scanning target: {str(e)}[/bold red]")
        return False

def run_interactive_cli(config, logger):
    """Run interactive CLI mode"""
    console.print(Panel.fit(
        "[bold blue]RexPloit Interactive CLI Mode[/bold blue]\n"
        "Type 'help' for available commands or 'exit' to quit",
        title="Interactive Mode",
        border_style="blue"
    ))
    
    # Initialize components
    payload_gen = core.PayloadGenerator(config)
    c2_manager = core.C2Manager(config)
    injector = core.Injector()
    scanner = core.VulnerabilityScanner()
    
    while True:
        try:
            cmd = Prompt.ask("[bold cyan]rexploit[/bold cyan]", default="help")
            cmd_parts = cmd.strip().split()
            
            if not cmd_parts:
                continue
                
            command = cmd_parts[0].lower()
            
            if command in ['exit', 'quit', 'q']:
                console.print("[yellow]Goodbye![/yellow]")
                break
                
            elif command == 'help':
                show_interactive_help()
                
            elif command == 'status':
                show_system_status(config, c2_manager)
                
            elif command == 'payload':
                interactive_payload_generation(payload_gen, cmd_parts[1:])
                
            elif command == 'c2':
                interactive_c2_management(c2_manager, cmd_parts[1:])
                
            elif command == 'scan':
                interactive_scanning(scanner, cmd_parts[1:])
                
            elif command == 'inject':
                interactive_injection(injector, cmd_parts[1:])
                
            elif command == 'config':
                interactive_config_management(config, cmd_parts[1:])
                
            elif command == 'clear':
                os.system('clear' if os.name == 'posix' else 'cls')
                
            else:
                console.print(f"[red]Unknown command: {command}[/red]")
                console.print("Type 'help' for available commands")
                
        except KeyboardInterrupt:
            console.print("\n[yellow]Use 'exit' to quit[/yellow]")
            continue
        except Exception as e:
            console.print(f"[bold red]Error: {str(e)}[/bold red]")
            continue
    
    return True

def show_interactive_help():
    """Show help for interactive mode"""
    console.print("\n[bold yellow]Available Commands:[/bold yellow]")
    
    from rich.table import Table
    table = Table(title="RexPloit Interactive Commands")
    table.add_column("Command", style="cyan")
    table.add_column("Description", style="white")
    table.add_column("Example", style="green")
    
    commands = [
        ("help", "Show this help message", "help"),
        ("status", "Show system status", "status"),
        ("payload", "Generate payloads", "payload python 192.168.1.100 4444"),
        ("c2", "Manage C2 frameworks", "c2 start sliver"),
        ("scan", "Perform security scans", "scan vuln 192.168.1.100"),
        ("inject", "Deploy payloads", "inject payload.py target1 target2"),
        ("config", "Manage configuration", "config show"),
        ("clear", "Clear screen", "clear"),
        ("exit/quit/q", "Exit interactive mode", "exit")
    ]
    
    for cmd, desc, example in commands:
        table.add_row(cmd, desc, example)
    
    console.print(table)
    console.print("\n[yellow]For detailed help on a command, type: <command> --help[/yellow]")

def show_system_status(config, c2_manager):
    """Show current system status"""
    console.print("\n[bold blue]System Status:[/bold blue]")
    
    from rich.table import Table
    table = Table(title="RexPloit System Status")
    table.add_column("Component", style="cyan")
    table.add_column("Status", style="green")
    table.add_column("Details", style="white")
    
    # Check C2 framework status
    try:
        c2_status = c2_manager.get_status()
        if c2_status["active"]:
            table.add_row("C2 Framework", "[green]Running[/green]", f"PID: {c2_status.get('pid', 'Unknown')}")
        else:
            table.add_row("C2 Framework", "[yellow]Stopped[/yellow]", "Not running")
    except:
        table.add_row("C2 Framework", "[red]Error[/red]", "Cannot determine status")
    
    # Check directories
    dirs_to_check = [core.PAYLOAD_DIR, core.LOG_DIR, core.C2_DIR]
    for dir_path in dirs_to_check:
        if os.path.exists(dir_path):
            file_count = len(os.listdir(dir_path))
            table.add_row(f"Directory {dir_path}", "[green]Exists[/green]", f"{file_count} files")
        else:
            table.add_row(f"Directory {dir_path}", "[yellow]Missing[/yellow]", "Will be created")
    
    # Check config
    if config:
        table.add_row("Configuration", "[green]Loaded[/green]", f"{len(config)} settings")
    else:
        table.add_row("Configuration", "[red]Missing[/red]", "No config loaded")
    
    console.print(table)

def interactive_payload_generation(payload_gen, args):
    """Interactive payload generation"""
    if not args:
        payload_type = Prompt.ask("Payload type", choices=["python", "bash", "powershell", "php", "perl"])
        lhost = Prompt.ask("Listener host")
        lport = int(Prompt.ask("Listener port", default="4444"))
        encode = Confirm.ask("Encode payload?", default=False)
        obfuscate = Confirm.ask("Obfuscate payload?", default=False)
    else:
        # Parse arguments
        try:
            payload_type = args[0]
            lhost = args[1]
            lport = int(args[2])
            encode = "--encode" in args
            obfuscate = "--obfuscate" in args
        except (IndexError, ValueError):
            console.print("[red]Usage: payload <type> <lhost> <lport> [--encode] [--obfuscate][/red]")
            return
    
    # Generate payload
    try:
        payload_map = {
            "python": "python_reverse_tcp",
            "bash": "bash_reverse_tcp",
            "powershell": "powershell_reverse_tcp", 
            "php": "php_reverse_tcp",
            "perl": "perl_reverse_tcp"
        }
        
        payload_type_internal = payload_map.get(payload_type)
        if not payload_type_internal:
            console.print(f"[red]Unsupported payload type: {payload_type}[/red]")
            return
        
        result = payload_gen.generate_payload(
            payload_type=payload_type_internal,
            lhost=lhost,
            lport=lport,
            encode=encode,
            obfuscate=obfuscate
        )
        
        if result["success"]:
            console.print(f"[bold green]Payload generated: {result['file_path']}[/bold green]")
            
            # Show preview if small
            if os.path.getsize(result['file_path']) < 512:
                with open(result['file_path'], 'r') as f:
                    content = f.read()
                from rich.syntax import Syntax
                syntax = Syntax(content, payload_type, theme="monokai", line_numbers=True)
                console.print(Panel(syntax, title="Payload Preview"))
        else:
            console.print(f"[red]Failed to generate payload: {result.get('error', 'Unknown error')}[/red]")
            
    except Exception as e:
        console.print(f"[red]Error: {str(e)}[/red]")

def interactive_c2_management(c2_manager, args):
    """Interactive C2 framework management"""
    if not args:
        action = Prompt.ask("Action", choices=["start", "stop", "status"])
        if action in ["start", "stop"]:
            framework = Prompt.ask("Framework", choices=["sliver", "villain", "hoaxshell"])
    else:
        try:
            action = args[0]
            framework = args[1] if len(args) > 1 else None
        except IndexError:
            console.print("[red]Usage: c2 <start|stop|status> [framework][/red]")
            return
    
    try:
        if action == "start":
            if not framework:
                framework = Prompt.ask("Framework", choices=["sliver", "villain", "hoaxshell"])
            
            console.print(f"[cyan]Starting {framework}...[/cyan]")
            success = c2_manager.start_framework(framework)
            
            if success:
                console.print(f"[green]{framework.capitalize()} started successfully[/green]")
            else:
                console.print(f"[red]Failed to start {framework}[/red]")
                
        elif action == "stop":
            console.print("[cyan]Stopping C2 framework...[/cyan]")
            success = c2_manager.stop_framework()
            
            if success:
                console.print("[green]C2 framework stopped[/green]")
            else:
                console.print("[red]Failed to stop C2 framework[/red]")
                
        elif action == "status":
            status = c2_manager.get_status()
            
            from rich.table import Table
            table = Table(title="C2 Framework Status")
            table.add_column("Property", style="cyan")
            table.add_column("Value", style="green")
            
            table.add_row("Active", str(status.get("active", False)))
            table.add_row("PID", str(status.get("pid", "N/A")))
            table.add_row("Listeners", str(status.get("listeners", 0)))
            table.add_row("Sessions", str(status.get("sessions", 0)))
            
            console.print(table)
            
    except Exception as e:
        console.print(f"[red]Error: {str(e)}[/red]")

def interactive_scanning(scanner, args):
    """Interactive vulnerability scanning"""
    if not args:
        scan_type = Prompt.ask("Scan type", choices=["vuln", "network", "port"], default="vuln")
        target = Prompt.ask("Target")
    else:
        try:
            scan_type = args[0]
            target = args[1]
        except IndexError:
            console.print("[red]Usage: scan <type> <target>[/red]")
            return
    
    try:
        from enhancements import TargetValidator
        validator = TargetValidator()
        
        if not validator.validate_target(target):
            console.print(f"[red]Invalid target: {target}[/red]")
            return
        
        console.print(f"[cyan]Running {scan_type} scan on {target}...[/cyan]")
        
        if scan_type == "vuln":
            results = scanner.scan_vulnerabilities(target)
        elif scan_type == "network":
            from enhancements import NetworkScanner
            net_scanner = NetworkScanner()
            results = net_scanner.scan_network(target)
        elif scan_type == "port":
            results = scanner.scan_ports(target)
        
        if results:
            from rich.table import Table
            table = Table(title=f"{scan_type.capitalize()} Scan Results")
            
            if scan_type == "vuln":
                table.add_column("Vulnerability", style="red")
                table.add_column("Severity", style="yellow")
                table.add_column("Description", style="cyan")
                
                for vuln in results:
                    table.add_row(vuln["name"], vuln["severity"], vuln["description"])
            else:
                table.add_column("Host", style="green")
                table.add_column("Port", style="cyan")
                table.add_column("Service", style="yellow")
                table.add_column("Status", style="red")
                
                for result in results:
                    table.add_row(
                        result.get("host", ""),
                        str(result.get("port", "")),
                        result.get("service", ""),
                        result.get("status", "")
                    )
            
            console.print(table)
        else:
            console.print("[yellow]No results found[/yellow]")
            
    except Exception as e:
        console.print(f"[red]Error: {str(e)}[/red]")

def interactive_injection(injector, args):
    """Interactive payload injection"""
    if not args:
        payload_file = Prompt.ask("Payload file")
        targets = Prompt.ask("Targets (space-separated)").split()
        method = Prompt.ask("Injection method", choices=["ssh", "smb", "http"], default="ssh")
    else:
        try:
            payload_file = args[0]
            targets = args[1:]
            method = "ssh"  # Default method
        except IndexError:
            console.print("[red]Usage: inject <payload_file> <target1> [target2] ...[/red]")
            return
    
    try:
        if not os.path.exists(payload_file):
            console.print(f"[red]Payload file not found: {payload_file}[/red]")
            return
        
        console.print(f"[cyan]Injecting {payload_file} to {len(targets)} target(s)...[/cyan]")
        
        results = []
        for target in targets:
            result = injector.inject_payload(payload_file, target, method=method)
            results.append((target, result))
        
        # Display results
        from rich.table import Table
        table = Table(title="Injection Results")
        table.add_column("Target", style="cyan")
        table.add_column("Status", style="green")
        table.add_column("Details", style="white")
        
        for target, result in results:
            status = "[green]Success[/green]" if result["success"] else "[red]Failed[/red]"
            table.add_row(target, status, result.get("message", ""))
        
        console.print(table)
        
    except Exception as e:
        console.print(f"[red]Error: {str(e)}[/red]")

def interactive_config_management(config, args):
    """Interactive configuration management"""
    if not args:
        action = Prompt.ask("Action", choices=["show", "set", "reset"])
    else:
        action = args[0]
    
    try:
        if action == "show":
            from rich.table import Table
            table = Table(title="Configuration")
            table.add_column("Setting", style="cyan")
            table.add_column("Value", style="green")
            
            for key, value in config.items():
                if "password" in key.lower() or "key" in key.lower():
                    value = "*" * len(str(value))
                table.add_row(key, str(value))
            
            console.print(table)
            
        elif action == "set":
            if len(args) >= 3:
                key, value = args[1], args[2]
            else:
                key = Prompt.ask("Setting name")
                value = Prompt.ask("Setting value")
            
            config[key] = value
            core.save_config(config)
            console.print(f"[green]Updated {key} = {value}[/green]")
            
        elif action == "reset":
            if Confirm.ask("Reset all configuration to defaults?", default=False):
                default_config = core.get_default_config()
                core.save_config(default_config)
                console.print("[green]Configuration reset to defaults[/green]")
            
    except Exception as e:
        console.print(f"[red]Error: {str(e)}[/red]")

def run_tests(logger):
    """Run all tests to validate framework"""
    logger.info("Running RexPloit test suite")
    
    console.print("[bold blue]Starting RexPloit Test Suite[/bold blue]")
    
    try:
        # Import and run tests
        from run_tests import main as run_test_main
        
        # Run all tests
        run_test_main(["--all"])
        
        return True
    except Exception as e:
        console.print(f"[bold red]Error running tests: {str(e)}[/bold red]")
        return False

def main():
    """Main entry point for unified RexPloit framework"""
    # Setup logging first
    logger = setup_logging()
    logger.info(f"Starting RexPloit v{VERSION} ({CODENAME})")
    
    # Parse arguments (this will handle --help and --version properly)
    args = parse_arguments()
    
    # Enable debug logging if requested
    if args.debug:
        logger.setLevel(logging.DEBUG)
        logger.debug("Debug logging enabled")
    
    # Display banner
    show_banner()
    
    # Check for command-line specific options
    if args.install:
        return check_dependencies(install=True)
    
    if args.check:
        return check_dependencies(install=False)
        
    # Check authorization
    if not check_authorization():
        console.print("[bold red]Access denied. Authorization required.[/bold red]")
        logger.warning("Authorization check failed")
        return False
        
    # Dependency check
    if not check_dependencies():
        console.print("[bold red]Critical dependencies missing. Cannot continue.[/bold red]")
        logger.error("Critical dependencies missing")
        return False
    
    # Run tests if requested
    if args.test:
        return run_tests(logger)
        
    # Always run in CLI mode - TUI/GUI modes have been removed
    return handle_cli_mode(args, logger)

if __name__ == "__main__":
    try:
        success = main()
        sys.exit(0 if success else 1)
    except KeyboardInterrupt:
        console.print("\n[yellow]Operation cancelled by user[/yellow]")
        sys.exit(0)
    except Exception as e:
        console.print(f"[bold red]Fatal error: {str(e)}[/bold red]")
        sys.exit(1)